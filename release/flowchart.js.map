{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///flowchart.js","webpack:///webpack/bootstrap 443db6e2f85f66074dae","webpack:///./index.js","webpack:///./src/flowchart.helpers.js","webpack:///./src/flowchart.symbol.js","webpack:///./src/flowchart.functions.js","webpack:///./src/flowchart.symbol.condition.js","webpack:///./src/flowchart.chart.js","webpack:///./src/flowchart.parse.js","webpack:///./src/flowchart.symbol.end.js","webpack:///./src/flowchart.symbol.inputoutput.js","webpack:///./src/flowchart.symbol.operation.js","webpack:///./src/flowchart.symbol.start.js","webpack:///./src/flowchart.symbol.subroutine.js","webpack:///./src/flowchart.defaults.js","webpack:///./src/flowchart.parseObject.js","webpack:///./src/flowchart.shim.js","webpack:///./src/jquery-plugin.js","webpack:///external \"Raphael\""],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE_16__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","parse","parseObject","FlowChart","window","flowchart","_defaults","options","defaultOptions","merged","attrname","_inherits","ctor","superCtor","Object","super_","prototype","create","constructor","value","enumerable","writable","configurable","TempCtor","defaults","inherits","Symbol","chart","symbol","group","paper","set","connectedTo","symbolType","flowstate","next_direction","next","undefined","text","key","node","setAttribute","getAttr","attr","text-anchor","x","fill","font-size","font","fontF","fontW","font-family","font-weight","link","target","maxWidth","words","split","tempText","ii","length","word","getBBox","width","substring","push","tmpMargin","stroke","stroke-width","height","insertBefore","y","initialize","drawAPI","drawLine","checkLineIntersection","attName","opt1","opt3","opt2","symbols","transform","getCenter","getX","getY","shiftX","setX","shiftY","setY","getTop","getBottom","getLeft","getRight","render","lineLength","rightPoint","isPositioned","self","shift","symb","hasSymbolUnder","len","diff","Math","abs","bottomPoint","renderLines","drawLineTo","origin","indexOf","line","right","bottom","left","symbolX","symbolY","symbolTop","symbolRight","symbolLeft","isOnSameColumn","isOnSameLine","isUnder","isUpper","isLeft","isRight","maxX","lineWith","rightStart","topEnd","bottomStart","diffX","leftStart","leftEnd","rightEnd","l","llen","lines","otherLine","ePath","lPath","iP","lenP","newPath","line1_from_x","line1_from_y","line1_to_x","line1_to_y","lP","lenlP","newLinePath","line2_from_x","line2_from_y","line2_to_x","line2_to_y","res","onLine1","onLine2","newSegment","splice","maxXFromLine","drawPath","location","points","path","pathValues","from","to","toString","arrow-end","centerText","textPath","isHorizontal","firstTo","line1StartX","line1StartY","line1EndX","line1EndY","line2StartX","line2StartY","line2EndX","line2EndY","denominator","b","numerator1","numerator2","result","Condition","textMargin","yes_direction","no_direction","yes","direction_yes","no","direction_no","max","startX","startY","start","yes_symbol","no_symbol","bottom_symbol","right_symbol","container","Raphael","handle","flowChart","nextSymbol","pathOk","then","startWith","maxHeight","maxY","minX","minY","x2","y2","scale","lineWidth","setSize","setViewBox","clean","paperDom","canvas","parentNode","removeChild","input","getSymbol","s","startIndex","endIndex","getNextPath","flowSymb","trim","drawSVG","getDisplaySymbol","dispSymbols","Start","diagram","End","Operation","InputOutput","Subroutine","Error","constructChart","prevDisp","prev","dispSymb","prevBreak","i0","i0len","line0","replace","substr","currentLine","sub","parts","join","txtAndState","pop","flowSymbols","lenS","realSymb","direction","condOpt","nextSymb","rect","innerWrap","line-width","line-length","text-margin","font-color","line-color","element-color","yes-text","no-text","class","end","condition","inputoutput","operation","subroutine","parseJson","symbolsArray","directionsArray","nextKey","Array","searchElement","TypeError","t","n","arguments","Number","Infinity","floor","k","lastIndexOf","min","String","jQuery","$","fn","each","$this","html"],"mappings":"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","file":"flowchart.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"Raphael\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"Raphael\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"Raphael\")) : factory(root[\"Raphael\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_16__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"Raphael\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"Raphael\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"Raphael\")) : factory(root[\"Raphael\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_16__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/*!******************!*\\\n  !*** ./index.js ***!\n  \\******************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(/*! ./src/flowchart.shim */ 14);\n\tvar parse = __webpack_require__(/*! ./src/flowchart.parse */ 6);\n\tvar parseObject = __webpack_require__(/*! ./src/flowchart.parseObject */ 13);\n\t__webpack_require__(/*! ./src/jquery-plugin */ 15);\n\t\n\tvar FlowChart = {\n\t\tparse: parse,\n\t\tparseObject: parseObject\n\t};\n\t\n\tif (typeof window !== 'undefined') {\n\t\twindow.flowchart = FlowChart;\n\t}\n\t\n\tmodule.exports = FlowChart;\n\n\n/***/ },\n/* 1 */\n/*!**********************************!*\\\n  !*** ./src/flowchart.helpers.js ***!\n  \\**********************************/\n/***/ function(module, exports) {\n\n\tfunction _defaults(options, defaultOptions) {\n\t  if (!options || typeof options === 'function') {\n\t    return defaultOptions;\n\t  }\n\t\n\t  var merged = {};\n\t  for (var attrname in defaultOptions) {\n\t    merged[attrname] = defaultOptions[attrname];\n\t  }\n\t\n\t  for (attrname in options) {\n\t    if (options[attrname]) {\n\t      if (typeof merged[attrname] === 'object') {\n\t        merged[attrname] = _defaults(merged[attrname], options[attrname]);\n\t      } else {\n\t        merged[attrname] = options[attrname];\n\t      }\n\t    }\n\t  }\n\t  return merged;\n\t}\n\t\n\tfunction _inherits(ctor, superCtor) {\n\t  if (typeof(Object.create) === 'function') {\n\t    // implementation from standard node.js 'util' module\n\t    ctor.super_ = superCtor;\n\t    ctor.prototype = Object.create(superCtor.prototype, {\n\t      constructor: {\n\t        value: ctor,\n\t        enumerable: false,\n\t        writable: true,\n\t        configurable: true\n\t      }\n\t    });\n\t  } else {\n\t    // old school shim for old browsers\n\t    ctor.super_ = superCtor;\n\t    var TempCtor = function () {};\n\t    TempCtor.prototype = superCtor.prototype;\n\t    ctor.prototype = new TempCtor();\n\t    ctor.prototype.constructor = ctor;\n\t  }\n\t}\n\t\n\t// move dependent functions to a container so that\n\t// they can be overriden easier in no jquery environment (node.js)\n\tmodule.exports = {\n\t  defaults: _defaults,\n\t  inherits: _inherits\n\t};\n\n\n/***/ },\n/* 2 */\n/*!*********************************!*\\\n  !*** ./src/flowchart.symbol.js ***!\n  \\*********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar drawAPI = __webpack_require__(/*! ./flowchart.functions */ 3);\n\tvar drawLine = drawAPI.drawLine;\n\tvar checkLineIntersection = drawAPI.checkLineIntersection;\n\t\n\tfunction Symbol(chart, options, symbol) {\n\t  this.chart = chart;\n\t  this.group = this.chart.paper.set();\n\t  this.symbol = symbol;\n\t  this.connectedTo = [];\n\t  this.symbolType = options.symbolType;\n\t  this.flowstate = (options.flowstate || 'future');\n\t\n\t  this.next_direction = options.next && options['direction_next'] ? options['direction_next'] : undefined;\n\t\n\t  this.text = this.chart.paper.text(0, 0, options.text);\n\t  //Raphael does not support the svg group tag so setting the text node id to the symbol node id plus t\n\t  if (options.key) { this.text.node.id = options.key + 't'; }\n\t  this.text.node.setAttribute('class', this.getAttr('class') + 't');\n\t\n\t  this.text.attr({\n\t    'text-anchor': 'start',\n\t    'x'          : this.getAttr('text-margin'),\n\t    'fill'       : this.getAttr('font-color'),\n\t    'font-size'  : this.getAttr('font-size')\n\t  });\n\t\n\t  var font  = this.getAttr('font');\n\t  var fontF = this.getAttr('font-family');\n\t  var fontW = this.getAttr('font-weight');\n\t\n\t  if (font) this.text.attr({ 'font': font });\n\t  if (fontF) this.text.attr({ 'font-family': fontF });\n\t  if (fontW) this.text.attr({ 'font-weight': fontW });\n\t\n\t  if (options.link) { this.text.attr('href', options.link); }\n\t  if (options.target) { this.text.attr('target', options.target); }\n\t\n\t  var maxWidth = this.getAttr('maxWidth');\n\t  if (maxWidth) {\n\t    // using this approach: http://stackoverflow.com/a/3153457/22466\n\t    var words = options.text.split(' ');\n\t    var tempText = \"\";\n\t    for (var i=0, ii=words.length; i<ii; i++) {\n\t      var word = words[i];\n\t      this.text.attr(\"text\", tempText + \" \" + word);\n\t      if (this.text.getBBox().width > maxWidth) {\n\t        tempText += \"\\n\" + word;\n\t      } else {\n\t        tempText += \" \" + word;\n\t      }\n\t    }\n\t    this.text.attr(\"text\", tempText.substring(1));\n\t  }\n\t\n\t  this.group.push(this.text);\n\t\n\t  if (symbol) {\n\t    var tmpMargin = this.getAttr('text-margin');\n\t\n\t    symbol.attr({\n\t      'fill' : this.getAttr('fill'),\n\t      'stroke' : this.getAttr('element-color'),\n\t      'stroke-width' : this.getAttr('line-width'),\n\t      'width' : this.text.getBBox().width + 2 * tmpMargin,\n\t      'height' : this.text.getBBox().height + 2 * tmpMargin\n\t    });\n\t\n\t    symbol.node.setAttribute('class', this.getAttr('class'));\n\t\n\t    if (options.link) { symbol.attr('href', options.link); }\n\t    if (options.target) { symbol.attr('target', options.target); }\n\t    if (options.key) { symbol.node.id = options.key; }\n\t\n\t    this.group.push(symbol);\n\t    symbol.insertBefore(this.text);\n\t\n\t    this.text.attr({\n\t      'y': symbol.getBBox().height/2\n\t    });\n\t\n\t    this.initialize();\n\t  }\n\t\n\t}\n\t\n\t/* Gets the attribute based on Flowstate, Symbol-Name and default, first found wins */\n\tSymbol.prototype.getAttr = function(attName) {\n\t  if (!this.chart) {\n\t    return undefined;\n\t  }\n\t  var opt3 = (this.chart.options) ? this.chart.options[attName] : undefined;\n\t  var opt2 = (this.chart.options.symbols) ? this.chart.options.symbols[this.symbolType][attName] : undefined;\n\t  var opt1;\n\t  if (this.chart.options.flowstate && this.chart.options.flowstate[this.flowstate]) {\n\t    opt1 = this.chart.options.flowstate[this.flowstate][attName];\n\t  }\n\t  return (opt1 || opt2 || opt3);\n\t};\n\t\n\tSymbol.prototype.initialize = function() {\n\t  this.group.transform('t' + this.getAttr('line-width') + ',' + this.getAttr('line-width'));\n\t\n\t  this.width = this.group.getBBox().width;\n\t  this.height = this.group.getBBox().height;\n\t};\n\t\n\tSymbol.prototype.getCenter = function() {\n\t  return {x: this.getX() + this.width/2,\n\t          y: this.getY() + this.height/2};\n\t};\n\t\n\tSymbol.prototype.getX = function() {\n\t  return this.group.getBBox().x;\n\t};\n\t\n\tSymbol.prototype.getY = function() {\n\t  return this.group.getBBox().y;\n\t};\n\t\n\tSymbol.prototype.shiftX = function(x) {\n\t  this.group.transform('t' + (this.getX() + x) + ',' + this.getY());\n\t};\n\t\n\tSymbol.prototype.setX = function(x) {\n\t  this.group.transform('t' + x + ',' + this.getY());\n\t};\n\t\n\tSymbol.prototype.shiftY = function(y) {\n\t  this.group.transform('t' + this.getX() + ',' + (this.getY() + y));\n\t};\n\t\n\tSymbol.prototype.setY = function(y) {\n\t  this.group.transform('t' + this.getX() + ',' + y);\n\t};\n\t\n\tSymbol.prototype.getTop = function() {\n\t  var y = this.getY();\n\t  var x = this.getX() + this.width/2;\n\t  return {x: x, y: y};\n\t};\n\t\n\tSymbol.prototype.getBottom = function() {\n\t  var y = this.getY() + this.height;\n\t  var x = this.getX() + this.width/2;\n\t  return {x: x, y: y};\n\t};\n\t\n\tSymbol.prototype.getLeft = function() {\n\t  var y = this.getY() + this.group.getBBox().height/2;\n\t  var x = this.getX();\n\t  return {x: x, y: y};\n\t};\n\t\n\tSymbol.prototype.getRight = function() {\n\t  var y = this.getY() + this.group.getBBox().height/2;\n\t  var x = this.getX() + this.group.getBBox().width;\n\t  return {x: x, y: y};\n\t};\n\t\n\tSymbol.prototype.render = function() {\n\t  if (this.next) {\n\t\n\t    var lineLength = this.getAttr('line-length');\n\t\n\t    if (this.next_direction === 'right') {\n\t\n\t      var rightPoint = this.getRight();\n\t\n\t      if (!this.next.isPositioned) {\n\t\n\t        this.next.setY(rightPoint.y - this.next.height/2);\n\t        this.next.shiftX(this.group.getBBox().x + this.width + lineLength);\n\t\n\t        var self = this;\n\t        (function shift() {\n\t          var hasSymbolUnder = false;\n\t          var symb;\n\t          for (var i = 0, len = self.chart.symbols.length; i < len; i++) {\n\t            symb = self.chart.symbols[i];\n\t\n\t            var diff = Math.abs(symb.getCenter().x - self.next.getCenter().x);\n\t            if (symb.getCenter().y > self.next.getCenter().y && diff <= self.next.width/2) {\n\t              hasSymbolUnder = true;\n\t              break;\n\t            }\n\t          }\n\t\n\t          if (hasSymbolUnder) {\n\t            self.next.setX(symb.getX() + symb.width + lineLength);\n\t            shift();\n\t          }\n\t        })();\n\t\n\t        this.next.isPositioned = true;\n\t\n\t        this.next.render();\n\t      }\n\t    } else {\n\t      var bottomPoint = this.getBottom();\n\t\n\t      if (!this.next.isPositioned) {\n\t        this.next.shiftY(this.getY() + this.height + lineLength);\n\t        this.next.setX(bottomPoint.x - this.next.width/2);\n\t        this.next.isPositioned = true;\n\t\n\t        this.next.render();\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\tSymbol.prototype.renderLines = function() {\n\t  if (this.next) {\n\t    if (this.next_direction) {\n\t      this.drawLineTo(this.next, '', this.next_direction);\n\t    } else {\n\t      this.drawLineTo(this.next);\n\t    }\n\t  }\n\t};\n\t\n\tSymbol.prototype.drawLineTo = function(symbol, text, origin) {\n\t  if (this.connectedTo.indexOf(symbol) < 0) {\n\t    this.connectedTo.push(symbol);\n\t  }\n\t\n\t  var x = this.getCenter().x,\n\t      y = this.getCenter().y,\n\t      right = this.getRight(),\n\t      bottom = this.getBottom(),\n\t      left = this.getLeft();\n\t\n\t  var symbolX = symbol.getCenter().x,\n\t      symbolY = symbol.getCenter().y,\n\t      symbolTop = symbol.getTop(),\n\t      symbolRight = symbol.getRight(),\n\t      symbolLeft = symbol.getLeft();\n\t\n\t  var isOnSameColumn = x === symbolX,\n\t      isOnSameLine = y === symbolY,\n\t      isUnder = y < symbolY,\n\t      isUpper = y > symbolY,\n\t      isLeft = x > symbolX,\n\t      isRight = x < symbolX;\n\t\n\t  var maxX = 0,\n\t      line,\n\t      lineLength = this.getAttr('line-length'),\n\t      lineWith = this.getAttr('line-width');\n\t\n\t  if ((!origin || origin === 'bottom') && isOnSameColumn && isUnder) {\n\t    line = drawLine(this.chart, bottom, symbolTop, text);\n\t    this.bottomStart = true;\n\t    symbol.topEnd = true;\n\t    maxX = bottom.x;\n\t  } else if ((!origin || origin === 'right') && isOnSameLine && isRight) {\n\t    line = drawLine(this.chart, right, symbolLeft, text);\n\t    this.rightStart = true;\n\t    symbol.leftEnd = true;\n\t    maxX = symbolLeft.x;\n\t  } else if ((!origin || origin === 'left') && isOnSameLine && isLeft) {\n\t    line = drawLine(this.chart, left, symbolRight, text);\n\t    this.leftStart = true;\n\t    symbol.rightEnd = true;\n\t    maxX = symbolRight.x;\n\t  } else if ((!origin || origin === 'right') && isOnSameColumn && isUpper) {\n\t    line = drawLine(this.chart, right, [\n\t      {x: right.x + lineLength/2, y: right.y},\n\t      {x: right.x + lineLength/2, y: symbolTop.y - lineLength/2},\n\t      {x: symbolTop.x, y: symbolTop.y - lineLength/2},\n\t      {x: symbolTop.x, y: symbolTop.y}\n\t    ], text);\n\t    this.rightStart = true;\n\t    symbol.topEnd = true;\n\t    maxX = right.x + lineLength/2;\n\t  } else if ((!origin || origin === 'right') && isOnSameColumn && isUnder) {\n\t    line = drawLine(this.chart, right, [\n\t      {x: right.x + lineLength/2, y: right.y},\n\t      {x: right.x + lineLength/2, y: symbolTop.y - lineLength/2},\n\t      {x: symbolTop.x, y: symbolTop.y - lineLength/2},\n\t      {x: symbolTop.x, y: symbolTop.y}\n\t    ], text);\n\t    this.rightStart = true;\n\t    symbol.topEnd = true;\n\t    maxX = right.x + lineLength/2;\n\t  } else if ((!origin || origin === 'bottom') && isLeft) {\n\t    if (this.leftEnd && isUpper) {\n\t      line = drawLine(this.chart, bottom, [\n\t        {x: bottom.x, y: bottom.y + lineLength/2},\n\t        {x: bottom.x + (bottom.x - symbolTop.x)/2, y: bottom.y + lineLength/2},\n\t        {x: bottom.x + (bottom.x - symbolTop.x)/2, y: symbolTop.y - lineLength/2},\n\t        {x: symbolTop.x, y: symbolTop.y - lineLength/2},\n\t        {x: symbolTop.x, y: symbolTop.y}\n\t      ], text);\n\t    } else {\n\t      line = drawLine(this.chart, bottom, [\n\t        {x: bottom.x, y: symbolTop.y - lineLength/2},\n\t        {x: symbolTop.x, y: symbolTop.y - lineLength/2},\n\t        {x: symbolTop.x, y: symbolTop.y}\n\t      ], text);\n\t    }\n\t    this.bottomStart = true;\n\t    symbol.topEnd = true;\n\t    maxX = bottom.x + (bottom.x - symbolTop.x)/2;\n\t  } else if ((!origin || origin === 'bottom') && isRight) {\n\t    line = drawLine(this.chart, bottom, [\n\t      {x: bottom.x, y: bottom.y + lineLength/2},\n\t      {x: bottom.x + (bottom.x - symbolTop.x)/2, y: bottom.y + lineLength/2},\n\t      {x: bottom.x + (bottom.x - symbolTop.x)/2, y: symbolTop.y - lineLength/2},\n\t      {x: symbolTop.x, y: symbolTop.y - lineLength/2},\n\t      {x: symbolTop.x, y: symbolTop.y}\n\t    ], text);\n\t    this.bottomStart = true;\n\t    symbol.topEnd = true;\n\t    maxX = bottom.x + (bottom.x - symbolTop.x)/2;\n\t  } else if ((origin && origin === 'right') && isLeft) {\n\t    line = drawLine(this.chart, right, [\n\t      {x: right.x + lineLength/2, y: right.y},\n\t      {x: right.x + lineLength/2, y: symbolTop.y - lineLength/2},\n\t      {x: symbolTop.x, y: symbolTop.y - lineLength/2},\n\t      {x: symbolTop.x, y: symbolTop.y}\n\t    ], text);\n\t    this.rightStart = true;\n\t    symbol.topEnd = true;\n\t    maxX = right.x + lineLength/2;\n\t  } else if ((origin && origin === 'right') && isRight) {\n\t    line = drawLine(this.chart, right, [\n\t      {x: symbolTop.x, y: right.y},\n\t      {x: symbolTop.x, y: symbolTop.y}\n\t    ], text);\n\t    this.rightStart = true;\n\t    symbol.topEnd = true;\n\t    maxX = right.x + lineLength/2;\n\t  } else if ((origin && origin === 'bottom') && isOnSameColumn && isUpper) {\n\t    line = drawLine(this.chart, bottom, [\n\t      {x: bottom.x, y: bottom.y + lineLength/2},\n\t      {x: right.x + lineLength/2, y: bottom.y + lineLength/2},\n\t      {x: right.x + lineLength/2, y: symbolTop.y - lineLength/2},\n\t      {x: symbolTop.x, y: symbolTop.y - lineLength/2},\n\t      {x: symbolTop.x, y: symbolTop.y}\n\t    ], text);\n\t    this.bottomStart = true;\n\t    symbol.topEnd = true;\n\t    maxX = bottom.x + lineLength/2;\n\t  } else if ((origin === 'left') && isOnSameColumn && isUpper) {\n\t    var diffX = left.x - lineLength/2;\n\t    if (symbolLeft.x < left.x) {\n\t      diffX = symbolLeft.x - lineLength/2;\n\t    }\n\t    line = drawLine(this.chart, left, [\n\t      {x: diffX, y: left.y},\n\t      {x: diffX, y: symbolTop.y - lineLength/2},\n\t      {x: symbolTop.x, y: symbolTop.y - lineLength/2},\n\t      {x: symbolTop.x, y: symbolTop.y}\n\t    ], text);\n\t    this.leftStart = true;\n\t    symbol.topEnd = true;\n\t    maxX = left.x;\n\t  } else if ((origin === 'left')) {\n\t    line = drawLine(this.chart, left, [\n\t      {x: symbolTop.x + (left.x - symbolTop.x)/ 2, y: left.y},\n\t      {x: symbolTop.x + (left.x - symbolTop.x)/ 2, y: symbolTop.y - lineLength/2},\n\t      {x: symbolTop.x, y: symbolTop.y - lineLength/2},\n\t      {x: symbolTop.x, y: symbolTop.y}\n\t    ], text);\n\t    this.leftStart = true;\n\t    symbol.topEnd = true;\n\t    maxX = left.x;\n\t  }\n\t\n\t  if (line) {\n\t    for (var l = 0, llen = this.chart.lines.length; l < llen; l++) {\n\t      var otherLine = this.chart.lines[l];\n\t      var len;\n\t\n\t      var ePath = otherLine.attr('path'),\n\t          lPath = line.attr('path');\n\t\n\t      for (var iP = 0, lenP = ePath.length - 1; iP < lenP; iP++) {\n\t        var newPath = [];\n\t        newPath.push(['M', ePath[iP][1], ePath[iP][2]]);\n\t        newPath.push(['L', ePath[iP + 1][1], ePath[iP + 1][2]]);\n\t\n\t        var line1_from_x = newPath[0][1];\n\t        var line1_from_y = newPath[0][2];\n\t        var line1_to_x = newPath[1][1];\n\t        var line1_to_y = newPath[1][2];\n\t\n\t        for (var lP = 0, lenlP = lPath.length - 1; lP < lenlP; lP++) {\n\t          var newLinePath = [];\n\t          newLinePath.push(['M', lPath[lP][1], lPath[lP][2]]);\n\t          newLinePath.push(['L', lPath[lP + 1][1], lPath[lP + 1][2]]);\n\t\n\t          var line2_from_x = newLinePath[0][1];\n\t          var line2_from_y = newLinePath[0][2];\n\t          var line2_to_x = newLinePath[1][1];\n\t          var line2_to_y = newLinePath[1][2];\n\t\n\t          var res = checkLineIntersection(line1_from_x, line1_from_y, line1_to_x, line1_to_y, line2_from_x, line2_from_y, line2_to_x, line2_to_y);\n\t          if (res.onLine1 && res.onLine2) {\n\t\n\t            var newSegment;\n\t            if (line2_from_y === line2_to_y) {\n\t              if (line2_from_x > line2_to_x) {\n\t                newSegment = ['L', res.x + lineWith * 2,  line2_from_y];\n\t                lPath.splice(lP + 1, 0, newSegment);\n\t                newSegment = ['C', res.x + lineWith * 2,  line2_from_y, res.x, line2_from_y - lineWith * 4, res.x - lineWith * 2, line2_from_y];\n\t                lPath.splice(lP + 2, 0, newSegment);\n\t                line.attr('path', lPath);\n\t              } else {\n\t                newSegment = ['L', res.x - lineWith * 2,  line2_from_y];\n\t                lPath.splice(lP + 1, 0, newSegment);\n\t                newSegment = ['C', res.x - lineWith * 2,  line2_from_y, res.x, line2_from_y - lineWith * 4, res.x + lineWith * 2, line2_from_y];\n\t                lPath.splice(lP + 2, 0, newSegment);\n\t                line.attr('path', lPath);\n\t              }\n\t            } else {\n\t              if (line2_from_y > line2_to_y) {\n\t                newSegment = ['L', line2_from_x, res.y + lineWith * 2];\n\t                lPath.splice(lP + 1, 0, newSegment);\n\t                newSegment = ['C', line2_from_x, res.y + lineWith * 2, line2_from_x + lineWith * 4, res.y, line2_from_x, res.y - lineWith * 2];\n\t                lPath.splice(lP + 2, 0, newSegment);\n\t                line.attr('path', lPath);\n\t              } else {\n\t                newSegment = ['L', line2_from_x, res.y - lineWith * 2];\n\t                lPath.splice(lP + 1, 0, newSegment);\n\t                newSegment = ['C', line2_from_x, res.y - lineWith * 2, line2_from_x + lineWith * 4, res.y, line2_from_x, res.y + lineWith * 2];\n\t                lPath.splice(lP + 2, 0, newSegment);\n\t                line.attr('path', lPath);\n\t              }\n\t            }\n\t\n\t            lP += 2;\n\t            len += 2;\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    this.chart.lines.push(line);\n\t  }\n\t\n\t  if (!this.chart.maxXFromLine || (this.chart.maxXFromLine && maxX > this.chart.maxXFromLine)) {\n\t    this.chart.maxXFromLine = maxX;\n\t  }\n\t};\n\t\n\tmodule.exports = Symbol;\n\n\n/***/ },\n/* 3 */\n/*!************************************!*\\\n  !*** ./src/flowchart.functions.js ***!\n  \\************************************/\n/***/ function(module, exports) {\n\n\tfunction drawPath(chart, location, points) {\n\t  var i, len;\n\t  var path = 'M{0},{1}';\n\t  for (i = 2, len = 2 * points.length + 2; i < len; i+=2) {\n\t    path += ' L{' + i + '},{' + (i + 1) + '}';\n\t  }\n\t  var pathValues = [location.x, location.y];\n\t  for (i = 0, len = points.length; i < len; i++) {\n\t    pathValues.push(points[i].x);\n\t    pathValues.push(points[i].y);\n\t  }\n\t  var symbol = chart.paper.path(path, pathValues);\n\t  symbol.attr('stroke', chart.options['element-color']);\n\t  symbol.attr('stroke-width', chart.options['line-width']);\n\t\n\t  var font = chart.options.font;\n\t  var fontF = chart.options['font-family'];\n\t  var fontW = chart.options['font-weight'];\n\t\n\t  if (font) symbol.attr({ 'font': font });\n\t  if (fontF) symbol.attr({ 'font-family': fontF });\n\t  if (fontW) symbol.attr({ 'font-weight': fontW });\n\t\n\t  return symbol;\n\t}\n\t\n\tfunction drawLine(chart, from, to, text) {\n\t  var i, len;\n\t\n\t  if (Object.prototype.toString.call(to) !== '[object Array]') {\n\t    to = [to];\n\t  }\n\t\n\t  var path = 'M{0},{1}';\n\t  for (i = 2, len = 2 * to.length + 2; i < len; i+=2) {\n\t    path += ' L{' + i + '},{' + (i + 1) + '}';\n\t  }\n\t  var pathValues = [from.x, from.y];\n\t  for (i = 0, len = to.length; i < len; i++) {\n\t    pathValues.push(to[i].x);\n\t    pathValues.push(to[i].y);\n\t  }\n\t\n\t  var line = chart.paper.path(path, pathValues);\n\t  line.attr({\n\t    stroke: chart.options['line-color'],\n\t    'stroke-width': chart.options['line-width'],\n\t    'arrow-end': chart.options['arrow-end']\n\t  });\n\t\n\t  var font = chart.options.font;\n\t  var fontF = chart.options['font-family'];\n\t  var fontW = chart.options['font-weight'];\n\t\n\t  if (font) line.attr({ 'font': font });\n\t  if (fontF) line.attr({ 'font-family': fontF });\n\t  if (fontW) line.attr({ 'font-weight': fontW });\n\t\n\t  if (text) {\n\t\n\t    var centerText = false;\n\t\n\t    var textPath = chart.paper.text(0, 0, text);\n\t\n\t    var isHorizontal = false;\n\t    var firstTo = to[0];\n\t\n\t    if (from.y === firstTo.y) {\n\t      isHorizontal = true;\n\t    }\n\t\n\t    var x = 0,\n\t        y = 0;\n\t\n\t    if (centerText) {\n\t      if (from.x > firstTo.x) {\n\t        x = from.x - (from.x - firstTo.x)/2;\n\t      } else {\n\t        x = firstTo.x - (firstTo.x - from.x)/2;\n\t      }\n\t\n\t      if (from.y > firstTo.y) {\n\t        y = from.y - (from.y - firstTo.y)/2;\n\t      } else {\n\t        y = firstTo.y - (firstTo.y - from.y)/2;\n\t      }\n\t\n\t      if (isHorizontal) {\n\t        x -= textPath.getBBox().width/2;\n\t        y -= chart.options['text-margin'];\n\t      } else {\n\t        x += chart.options['text-margin'];\n\t        y -= textPath.getBBox().height/2;\n\t      }\n\t    } else {\n\t      x = from.x;\n\t      y = from.y;\n\t\n\t      if (isHorizontal) {\n\t        x += chart.options['text-margin']/2;\n\t        y -= chart.options['text-margin'];\n\t      } else {\n\t        x += chart.options['text-margin']/2;\n\t        y += chart.options['text-margin'];\n\t      }\n\t    }\n\t\n\t    textPath.attr({\n\t      'text-anchor': 'start',\n\t      'font-size': chart.options['font-size'],\n\t      'fill': chart.options['font-color'],\n\t      x: x,\n\t      y: y\n\t    });\n\t\n\t    if (font) textPath.attr({ 'font': font });\n\t    if (fontF) textPath.attr({ 'font-family': fontF });\n\t    if (fontW) textPath.attr({ 'font-weight': fontW });\n\t  }\n\t\n\t  return line;\n\t}\n\t\n\tfunction checkLineIntersection(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {\n\t  // if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point\n\t  var denominator, a, b, numerator1, numerator2, result = {\n\t    x: null,\n\t    y: null,\n\t    onLine1: false,\n\t    onLine2: false\n\t  };\n\t  denominator = ((line2EndY - line2StartY) * (line1EndX - line1StartX)) - ((line2EndX - line2StartX) * (line1EndY - line1StartY));\n\t  if (denominator === 0) {\n\t    return result;\n\t  }\n\t  a = line1StartY - line2StartY;\n\t  b = line1StartX - line2StartX;\n\t  numerator1 = ((line2EndX - line2StartX) * a) - ((line2EndY - line2StartY) * b);\n\t  numerator2 = ((line1EndX - line1StartX) * a) - ((line1EndY - line1StartY) * b);\n\t  a = numerator1 / denominator;\n\t  b = numerator2 / denominator;\n\t\n\t  // if we cast these lines infinitely in both directions, they intersect here:\n\t  result.x = line1StartX + (a * (line1EndX - line1StartX));\n\t  result.y = line1StartY + (a * (line1EndY - line1StartY));\n\t  /*\n\t  // it is worth noting that this should be the same as:\n\t  x = line2StartX + (b * (line2EndX - line2StartX));\n\t  y = line2StartX + (b * (line2EndY - line2StartY));\n\t  */\n\t  // if line1 is a segment and line2 is infinite, they intersect if:\n\t  if (a > 0 && a < 1) {\n\t    result.onLine1 = true;\n\t  }\n\t  // if line2 is a segment and line1 is infinite, they intersect if:\n\t  if (b > 0 && b < 1) {\n\t    result.onLine2 = true;\n\t  }\n\t  // if line1 and line2 are segments, they intersect if both of the above are true\n\t  return result;\n\t}\n\t\n\tmodule.exports = {\n\t\tdrawPath: drawPath,\n\t\tdrawLine: drawLine,\n\t\tcheckLineIntersection: checkLineIntersection\n\t};\n\n\n/***/ },\n/* 4 */\n/*!*******************************************!*\\\n  !*** ./src/flowchart.symbol.condition.js ***!\n  \\*******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Symbol = __webpack_require__(/*! ./flowchart.symbol */ 2);\n\tvar inherits = __webpack_require__(/*! ./flowchart.helpers */ 1).inherits;\n\tvar drawAPI = __webpack_require__(/*! ./flowchart.functions */ 3);\n\tvar drawPath = drawAPI.drawPath;\n\t\n\tfunction Condition(chart, options) {\n\t  options = options || {};\n\t  Symbol.call(this, chart, options);\n\t  this.textMargin = this.getAttr('text-margin');\n\t  this.yes_direction = 'bottom';\n\t  this.no_direction = 'right';\n\t  if (options.yes && options.direction_yes && options.no && !options.direction_no) {\n\t    if (options.direction_yes === 'right') {\n\t      this.no_direction = 'bottom';\n\t      this.yes_direction = 'right';\n\t    } else {\n\t      this.no_direction = 'right';\n\t      this.yes_direction = 'bottom';\n\t    }\n\t  } else if (options.yes && !options.direction_yes && options.no && options.direction_no) {\n\t    if (options.direction_no === 'right') {\n\t      this.yes_direction = 'bottom';\n\t      this.no_direction = 'right';\n\t    } else {\n\t      this.yes_direction = 'right';\n\t      this.no_direction = 'bottom';\n\t    }\n\t  } else {\n\t    this.yes_direction = 'bottom';\n\t    this.no_direction = 'right';\n\t  }\n\t\n\t  this.yes_direction = this.yes_direction || 'bottom';\n\t  this.no_direction = this.no_direction || 'right';\n\t\n\t  this.text.attr({\n\t    x: this.textMargin * 2\n\t  });\n\t\n\t  var width = this.text.getBBox().width + 3 * this.textMargin;\n\t  width += width/2;\n\t  var height = this.text.getBBox().height + 2 * this.textMargin;\n\t  height += height/2;\n\t  height = Math.max(width * 0.5, height);\n\t  var startX = width/4;\n\t  var startY = height/4;\n\t\n\t  this.text.attr({\n\t    x: startX + this.textMargin/2\n\t  });\n\t\n\t  var start = {x: startX, y: startY};\n\t  var points = [\n\t    {x: startX - width/4, y: startY + height/4},\n\t    {x: startX - width/4 + width/2, y: startY + height/4 + height/2},\n\t    {x: startX - width/4 + width, y: startY + height/4},\n\t    {x: startX - width/4 + width/2, y: startY + height/4 - height/2},\n\t    {x: startX - width/4, y: startY + height/4}\n\t  ];\n\t\n\t  var symbol = drawPath(chart, start, points);\n\t\n\t  symbol.attr({\n\t    stroke: this.getAttr('element-color'),\n\t    'stroke-width': this.getAttr('line-width'),\n\t    fill: this.getAttr('fill')\n\t  });\n\t  if (options.link) { symbol.attr('href', options.link); }\n\t  if (options.target) { symbol.attr('target', options.target); }\n\t  if (options.key) { symbol.node.id = options.key; }\n\t  symbol.node.setAttribute('class', this.getAttr('class'));\n\t\n\t  this.text.attr({\n\t    y: symbol.getBBox().height/2\n\t  });\n\t\n\t  this.group.push(symbol);\n\t  symbol.insertBefore(this.text);\n\t\n\t  this.initialize();\n\t}\n\tinherits(Condition, Symbol);\n\t\n\tCondition.prototype.render = function() {\n\t\n\t  if (this.yes_direction) {\n\t    this[this.yes_direction + '_symbol'] = this.yes_symbol;\n\t  }\n\t\n\t  if (this.no_direction) {\n\t    this[this.no_direction + '_symbol'] = this.no_symbol;\n\t  }\n\t\n\t  var lineLength = this.getAttr('line-length');\n\t\n\t  if (this.bottom_symbol) {\n\t    var bottomPoint = this.getBottom();\n\t\n\t    if (!this.bottom_symbol.isPositioned) {\n\t      this.bottom_symbol.shiftY(this.getY() + this.height + lineLength);\n\t      this.bottom_symbol.setX(bottomPoint.x - this.bottom_symbol.width/2);\n\t      this.bottom_symbol.isPositioned = true;\n\t\n\t      this.bottom_symbol.render();\n\t    }\n\t  }\n\t\n\t  if (this.right_symbol) {\n\t    var rightPoint = this.getRight();\n\t\n\t    if (!this.right_symbol.isPositioned) {\n\t\n\t      this.right_symbol.setY(rightPoint.y - this.right_symbol.height/2);\n\t      this.right_symbol.shiftX(this.group.getBBox().x + this.width + lineLength);\n\t\n\t      var self = this;\n\t      (function shift() {\n\t        var hasSymbolUnder = false;\n\t        var symb;\n\t        for (var i = 0, len = self.chart.symbols.length; i < len; i++) {\n\t          symb = self.chart.symbols[i];\n\t\n\t          var diff = Math.abs(symb.getCenter().x - self.right_symbol.getCenter().x);\n\t          if (symb.getCenter().y > self.right_symbol.getCenter().y && diff <= self.right_symbol.width/2) {\n\t            hasSymbolUnder = true;\n\t            break;\n\t          }\n\t        }\n\t\n\t        if (hasSymbolUnder) {\n\t          self.right_symbol.setX(symb.getX() + symb.width + lineLength);\n\t          shift();\n\t        }\n\t      })();\n\t\n\t      this.right_symbol.isPositioned = true;\n\t\n\t      this.right_symbol.render();\n\t    }\n\t  }\n\t};\n\t\n\tCondition.prototype.renderLines = function() {\n\t  if (this.yes_symbol) {\n\t    this.drawLineTo(this.yes_symbol, this.getAttr('yes-text'), this.yes_direction);\n\t  }\n\t\n\t  if (this.no_symbol) {\n\t    this.drawLineTo(this.no_symbol, this.getAttr('no-text'), this.no_direction);\n\t  }\n\t};\n\t\n\tmodule.exports = Condition;\n\n\n/***/ },\n/* 5 */\n/*!********************************!*\\\n  !*** ./src/flowchart.chart.js ***!\n  \\********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Raphael = __webpack_require__(/*! raphael */ 16);\n\tvar defaults = __webpack_require__(/*! ./flowchart.helpers */ 1).defaults;\n\tvar defaultOptions = __webpack_require__(/*! ./flowchart.defaults */ 12);\n\tvar Condition = __webpack_require__(/*! ./flowchart.symbol.condition */ 4);\n\t\n\tfunction FlowChart(container, options) {\n\t  options = options || {};\n\t\n\t  this.paper = new Raphael(container);\n\t\n\t  this.options = defaults(options, defaultOptions);\n\t\n\t  this.symbols = [];\n\t  this.lines = [];\n\t  this.start = null;\n\t}\n\t\n\tFlowChart.prototype.handle = function(symbol) {\n\t  if (this.symbols.indexOf(symbol) <= -1) {\n\t    this.symbols.push(symbol);\n\t  }\n\t\n\t  var flowChart = this;\n\t\n\t  if (symbol instanceof(Condition)) {\n\t    symbol.yes = function(nextSymbol) {\n\t      symbol.yes_symbol = nextSymbol;\n\t      if(symbol.no_symbol) {\n\t        symbol.pathOk = true;\n\t      }\n\t      return flowChart.handle(nextSymbol);\n\t    };\n\t    symbol.no = function(nextSymbol) {\n\t      symbol.no_symbol = nextSymbol;\n\t      if(symbol.yes_symbol) {\n\t        symbol.pathOk = true;\n\t      }\n\t      return flowChart.handle(nextSymbol);\n\t    };\n\t  } else {\n\t    symbol.then = function(nextSymbol) {\n\t      symbol.next = nextSymbol;\n\t      symbol.pathOk = true;\n\t      return flowChart.handle(nextSymbol);\n\t    };\n\t  }\n\t\n\t  return symbol;\n\t};\n\t\n\tFlowChart.prototype.startWith = function(symbol) {\n\t  this.start = symbol;\n\t  return this.handle(symbol);\n\t};\n\t\n\tFlowChart.prototype.render = function() {\n\t  var maxWidth = 0,\n\t      maxHeight = 0,\n\t      i = 0,\n\t      len = 0,\n\t      maxX = 0,\n\t      maxY = 0,\n\t      minX = 0,\n\t      minY = 0,\n\t      symbol,\n\t      line;\n\t\n\t  for (i = 0, len = this.symbols.length; i < len; i++) {\n\t    symbol = this.symbols[i];\n\t    if (symbol.width > maxWidth) {\n\t      maxWidth = symbol.width;\n\t    }\n\t    if (symbol.height > maxHeight) {\n\t      maxHeight = symbol.height;\n\t    }\n\t  }\n\t\n\t  for (i = 0, len = this.symbols.length; i < len; i++) {\n\t    symbol = this.symbols[i];\n\t    symbol.shiftX(this.options.x + (maxWidth - symbol.width)/2 + this.options['line-width']);\n\t    symbol.shiftY(this.options.y + (maxHeight - symbol.height)/2 + this.options['line-width']);\n\t  }\n\t\n\t  this.start.render();\n\t  // for (i = 0, len = this.symbols.length; i < len; i++) {\n\t  //   symbol = this.symbols[i];\n\t  //   symbol.render();\n\t  // }\n\t\n\t  for (i = 0, len = this.symbols.length; i < len; i++) {\n\t    symbol = this.symbols[i];\n\t    symbol.renderLines();\n\t  }\n\t\n\t  maxX = this.maxXFromLine;\n\t\n\t  for (i = 0, len = this.symbols.length; i < len; i++) {\n\t    symbol = this.symbols[i];\n\t    var x = symbol.getX() + symbol.width;\n\t    var y = symbol.getY() + symbol.height;\n\t    if (x > maxX) {\n\t      maxX = x;\n\t    }\n\t    if (y > maxY) {\n\t      maxY = y;\n\t    }\n\t  }\n\t\n\t  for (i = 0, len = this.lines.length; i < len; i++) {\n\t    line = this.lines[i].getBBox();\n\t    var x = line.x;\n\t    var y = line.y;\n\t    var x2 = line.x2;\n\t    var y2 = line.y2;\n\t    if (x < minX) {\n\t      minX = x;\n\t    }\n\t    if (y < minY) {\n\t      minY = y;\n\t    }\n\t    if (x2 > maxX) {\n\t      maxX = x2;\n\t    }\n\t    if (y2 > maxY) {\n\t      maxY = y2;\n\t    }\n\t  }\n\t\n\t  var scale = this.options['scale'];\n\t  var lineWidth = this.options['line-width'];\n\t\n\t  if (minX < 0) minX -= lineWidth;\n\t  if (minY < 0) minY -= lineWidth;\n\t\n\t  var width = maxX + lineWidth - minX;\n\t  var height = maxY + lineWidth - minY;\n\t\n\t  this.paper.setSize(width * scale, height * scale);\n\t  this.paper.setViewBox(minX, minY, width, height, true);\n\t};\n\t\n\tFlowChart.prototype.clean = function() {\n\t  if (this.paper) {\n\t    var paperDom = this.paper.canvas;\n\t    paperDom.parentNode.removeChild(paperDom);\n\t  }\n\t};\n\t\n\tmodule.exports = FlowChart;\n\n\n/***/ },\n/* 6 */\n/*!********************************!*\\\n  !*** ./src/flowchart.parse.js ***!\n  \\********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar FlowChart = __webpack_require__(/*! ./flowchart.chart */ 5);\n\tvar Start = __webpack_require__(/*! ./flowchart.symbol.start */ 10);\n\tvar End = __webpack_require__(/*! ./flowchart.symbol.end */ 7);\n\tvar Operation = __webpack_require__(/*! ./flowchart.symbol.operation */ 9);\n\tvar InputOutput = __webpack_require__(/*! ./flowchart.symbol.inputoutput */ 8);\n\tvar Subroutine = __webpack_require__(/*! ./flowchart.symbol.subroutine */ 11);\n\tvar Condition = __webpack_require__(/*! ./flowchart.symbol.condition */ 4);\n\t\n\tfunction parse(input) {\n\t  input = input || '';\n\t  input = input.trim();\n\t\n\t  var chart = {\n\t    symbols: {},\n\t    start: null,\n\t    drawSVG: function(container, options) {\n\t      var self = this;\n\t\n\t      if (this.diagram) {\n\t        this.diagram.clean();\n\t      }\n\t\n\t      var diagram = new FlowChart(container, options);\n\t      this.diagram = diagram;\n\t      var dispSymbols = {};\n\t\n\t      function getDisplaySymbol(s) {\n\t        if (dispSymbols[s.key]) {\n\t          return dispSymbols[s.key];\n\t        }\n\t\n\t        switch (s.symbolType) {\n\t          case 'start':\n\t            dispSymbols[s.key] = new Start(diagram, s);\n\t            break;\n\t          case 'end':\n\t            dispSymbols[s.key] = new End(diagram, s);\n\t            break;\n\t          case 'operation':\n\t            dispSymbols[s.key] = new Operation(diagram, s);\n\t            break;\n\t          case 'inputoutput':\n\t            dispSymbols[s.key] = new InputOutput(diagram, s);\n\t            break;\n\t          case 'subroutine':\n\t            dispSymbols[s.key] = new Subroutine(diagram, s);\n\t            break;\n\t          case 'condition':\n\t            dispSymbols[s.key] = new Condition(diagram, s);\n\t            break;\n\t          default:\n\t            return new Error('Wrong symbol type!');\n\t        }\n\t\n\t        return dispSymbols[s.key];\n\t      }\n\t\n\t      (function constructChart(s, prevDisp, prev) {\n\t        var dispSymb = getDisplaySymbol(s);\n\t\n\t        if (self.start === s) {\n\t          diagram.startWith(dispSymb);\n\t        } else if (prevDisp && prev && !prevDisp.pathOk) {\n\t          if (prevDisp instanceof(Condition)) {\n\t            if (prev.yes === s) {\n\t              prevDisp.yes(dispSymb);\n\t            }\n\t            if (prev.no === s) {\n\t              prevDisp.no(dispSymb);\n\t            }\n\t          } else {\n\t            prevDisp.then(dispSymb);\n\t          }\n\t        }\n\t\n\t        if (dispSymb.pathOk) {\n\t          return dispSymb;\n\t        }\n\t\n\t        if (dispSymb instanceof(Condition)) {\n\t          if (s.yes) {\n\t            constructChart(s.yes, dispSymb, s);\n\t          }\n\t          if (s.no) {\n\t            constructChart(s.no, dispSymb, s);\n\t          }\n\t        } else if (s.next) {\n\t          constructChart(s.next, dispSymb, s);\n\t        }\n\t\n\t        return dispSymb;\n\t      })(this.start);\n\t\n\t      diagram.render();\n\t    },\n\t    clean: function() {\n\t      this.diagram.clean();\n\t    }\n\t  };\n\t\n\t  var lines = [];\n\t  var prevBreak = 0;\n\t  for (var i0 = 1, i0len = input.length; i0 < i0len; i0++) {\n\t    if(input[i0] === '\\n' && input[i0 - 1] !== '\\\\') {\n\t      var line0 = input.substring(prevBreak, i0);\n\t      prevBreak = i0 + 1;\n\t      lines.push(line0.replace(/\\\\\\n/g, '\\n'));\n\t    }\n\t  }\n\t\n\t  if(prevBreak < input.length) {\n\t    lines.push(input.substr(prevBreak));\n\t  }\n\t\n\t  for (var l = 1, len = lines.length; l < len;) {\n\t    var currentLine = lines[l];\n\t\n\t    if (currentLine.indexOf('->') < 0 && currentLine.indexOf('=>') < 0) {\n\t      lines[l - 1] += '\\n' + currentLine;\n\t      lines.splice(l, 1);\n\t      len--;\n\t    } else {\n\t      l++;\n\t    }\n\t  }\n\t\n\t  function getSymbol(s) {\n\t    var startIndex = s.indexOf('(') + 1;\n\t    var endIndex = s.indexOf(')');\n\t    if (startIndex >= 0 && endIndex >= 0) {\n\t      return chart.symbols[s.substring(0, startIndex - 1)];\n\t    }\n\t    return chart.symbols[s];\n\t  }\n\t\n\t  function getNextPath(s) {\n\t    var next = 'next';\n\t    var startIndex = s.indexOf('(') + 1;\n\t    var endIndex = s.indexOf(')');\n\t    if (startIndex >= 0 && endIndex >= 0) {\n\t      next = flowSymb.substring(startIndex, endIndex);\n\t      if (next.indexOf(',') < 0) {\n\t        if (next !== 'yes' && next !== 'no') {\n\t          next = 'next, ' + next;\n\t        }\n\t      }\n\t    }\n\t    return next;\n\t  }\n\t\n\t  while (lines.length > 0) {\n\t    var line = lines.splice(0, 1)[0];\n\t\n\t    if (line.indexOf('=>') >= 0) {\n\t      // definition\n\t      var parts = line.split('=>');\n\t      var symbol = {\n\t        key: parts[0],\n\t        symbolType: parts[1],\n\t        text: null,\n\t        link: null,\n\t        target: null,\n\t        flowstate: null\n\t      };\n\t\n\t      var sub;\n\t\n\t      if (symbol.symbolType.indexOf(': ') >= 0) {\n\t        sub = symbol.symbolType.split(': ');\n\t        symbol.symbolType = sub.shift();\n\t        symbol.text = sub.join(': ');\n\t      }\n\t\n\t      if (symbol.text && symbol.text.indexOf(':>') >= 0) {\n\t        sub = symbol.text.split(':>');\n\t        symbol.text = sub.shift();\n\t        symbol.link = sub.join(':>');\n\t      } else if (symbol.symbolType.indexOf(':>') >= 0) {\n\t        sub = symbol.symbolType.split(':>');\n\t        symbol.symbolType = sub.shift();\n\t        symbol.link = sub.join(':>');\n\t      }\n\t\n\t      if (symbol.symbolType.indexOf('\\n') >= 0) {\n\t        symbol.symbolType = symbol.symbolType.split('\\n')[0];\n\t      }\n\t\n\t      /* adding support for links */\n\t      if (symbol.link) {\n\t        var startIndex = symbol.link.indexOf('[') + 1;\n\t        var endIndex = symbol.link.indexOf(']');\n\t        if (startIndex >= 0 && endIndex >= 0) {\n\t          symbol.target = symbol.link.substring(startIndex, endIndex);\n\t          symbol.link = symbol.link.substring(0, startIndex - 1);\n\t        }\n\t      }\n\t      /* end of link support */\n\t\n\t      /* adding support for flowstates */\n\t      if (symbol.text) {\n\t        if (symbol.text.indexOf('|') >= 0) {\n\t          var txtAndState = symbol.text.split('|');\n\t          symbol.flowstate = txtAndState.pop().trim();\n\t          symbol.text = txtAndState.join('|');\n\t        }\n\t      }\n\t      /* end of flowstate support */\n\t\n\t      chart.symbols[symbol.key] = symbol;\n\t\n\t    } else if (line.indexOf('->') >= 0) {\n\t      // flow\n\t      var flowSymbols = line.split('->');\n\t      for (var i = 0, lenS = flowSymbols.length; i < lenS; i++) {\n\t        var flowSymb = flowSymbols[i];\n\t\n\t        var realSymb = getSymbol(flowSymb);\n\t        var next = getNextPath(flowSymb);\n\t\n\t        var direction = null;\n\t        if (next.indexOf(',') >= 0) {\n\t          var condOpt = next.split(',');\n\t          next = condOpt[0];\n\t          direction = condOpt[1].trim();\n\t        }\n\t\n\t        if (!chart.start) {\n\t          chart.start = realSymb;\n\t        }\n\t\n\t        if (i + 1 < lenS) {\n\t          var nextSymb = flowSymbols[i + 1];\n\t          realSymb[next] = getSymbol(nextSymb);\n\t          realSymb['direction_' + next] = direction;\n\t          direction = null;\n\t        }\n\t      }\n\t    }\n\t\n\t  }\n\t  return chart;\n\t}\n\t\n\tmodule.exports = parse;\n\n\n/***/ },\n/* 7 */\n/*!*************************************!*\\\n  !*** ./src/flowchart.symbol.end.js ***!\n  \\*************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Symbol = __webpack_require__(/*! ./flowchart.symbol */ 2);\n\tvar inherits = __webpack_require__(/*! ./flowchart.helpers */ 1).inherits;\n\t\n\tfunction End(chart, options) {\n\t  var symbol = chart.paper.rect(0, 0, 0, 0, 20);\n\t  options = options || {};\n\t  options.text = options.text || 'End';\n\t  Symbol.call(this, chart, options, symbol);\n\t}\n\tinherits(End, Symbol);\n\t\n\tmodule.exports = End;\n\n\n/***/ },\n/* 8 */\n/*!*********************************************!*\\\n  !*** ./src/flowchart.symbol.inputoutput.js ***!\n  \\*********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Symbol = __webpack_require__(/*! ./flowchart.symbol */ 2);\n\tvar inherits = __webpack_require__(/*! ./flowchart.helpers */ 1).inherits;\n\tvar drawAPI = __webpack_require__(/*! ./flowchart.functions */ 3);\n\tvar drawPath = drawAPI.drawPath;\n\t\n\tfunction InputOutput(chart, options) {\n\t  options = options || {};\n\t  Symbol.call(this, chart, options);\n\t  this.textMargin = this.getAttr('text-margin');\n\t\n\t  this.text.attr({\n\t    x: this.textMargin * 3\n\t  });\n\t\n\t  var width = this.text.getBBox().width + 4 * this.textMargin;\n\t  var height = this.text.getBBox().height + 2 * this.textMargin;\n\t  var startX = this.textMargin;\n\t  var startY = height/2;\n\t\n\t  var start = {x: startX, y: startY};\n\t  var points = [\n\t    {x: startX - this.textMargin, y: height},\n\t    {x: startX - this.textMargin + width, y: height},\n\t    {x: startX - this.textMargin + width + 2 * this.textMargin, y: 0},\n\t    {x: startX - this.textMargin + 2 * this.textMargin, y: 0},\n\t    {x: startX, y: startY}\n\t  ];\n\t\n\t  var symbol = drawPath(chart, start, points);\n\t\n\t  symbol.attr({\n\t    stroke: this.getAttr('element-color'),\n\t    'stroke-width': this.getAttr('line-width'),\n\t    fill: this.getAttr('fill')\n\t  });\n\t  if (options.link) { symbol.attr('href', options.link); }\n\t  if (options.target) { symbol.attr('target', options.target); }\n\t  if (options.key) { symbol.node.id = options.key; }\n\t  symbol.node.setAttribute('class', this.getAttr('class'));\n\t\n\t  this.text.attr({\n\t    y: symbol.getBBox().height/2\n\t  });\n\t\n\t  this.group.push(symbol);\n\t  symbol.insertBefore(this.text);\n\t\n\t  this.initialize();\n\t}\n\tinherits(InputOutput, Symbol);\n\t\n\tInputOutput.prototype.getLeft = function() {\n\t  var y = this.getY() + this.group.getBBox().height/2;\n\t  var x = this.getX() + this.textMargin;\n\t  return {x: x, y: y};\n\t};\n\t\n\tInputOutput.prototype.getRight = function() {\n\t  var y = this.getY() + this.group.getBBox().height/2;\n\t  var x = this.getX() + this.group.getBBox().width - this.textMargin;\n\t  return {x: x, y: y};\n\t};\n\t\n\tmodule.exports = InputOutput;\n\n\n/***/ },\n/* 9 */\n/*!*******************************************!*\\\n  !*** ./src/flowchart.symbol.operation.js ***!\n  \\*******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Symbol = __webpack_require__(/*! ./flowchart.symbol */ 2);\n\tvar inherits = __webpack_require__(/*! ./flowchart.helpers */ 1).inherits;\n\t\n\tfunction Operation(chart, options) {\n\t  var symbol = chart.paper.rect(0, 0, 0, 0);\n\t  options = options || {};\n\t  Symbol.call(this, chart, options, symbol);\n\t}\n\tinherits(Operation, Symbol);\n\t\n\tmodule.exports = Operation;\n\n\n/***/ },\n/* 10 */\n/*!***************************************!*\\\n  !*** ./src/flowchart.symbol.start.js ***!\n  \\***************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Symbol = __webpack_require__(/*! ./flowchart.symbol */ 2);\n\tvar inherits = __webpack_require__(/*! ./flowchart.helpers */ 1).inherits;\n\t\n\tfunction Start(chart, options) {\n\t  var symbol = chart.paper.rect(0, 0, 0, 0, 20);\n\t  options = options || {};\n\t  options.text = options.text || 'Start';\n\t  Symbol.call(this, chart, options, symbol);\n\t}\n\tinherits(Start, Symbol);\n\t\n\tmodule.exports = Start;\n\t\n\t// Start.prototype.render = function() {\n\t//   if (this.next) {\n\t//     var lineLength = this.chart.options.symbols[this.symbolType]['line-length'] || this.chart.options['line-length'];\n\t\n\t//     var bottomPoint = this.getBottom();\n\t//     var topPoint = this.next.getTop();\n\t\n\t//     if (!this.next.isPositioned) {\n\t//       this.next.shiftY(this.getY() + this.height + lineLength);\n\t//       this.next.setX(bottomPoint.x - this.next.width/2);\n\t//       this.next.isPositioned = true;\n\t\n\t//       this.next.render();\n\t//     }\n\t//   }\n\t// };\n\t\n\t// Start.prototype.renderLines = function() {\n\t//   if (this.next) {\n\t//     this.drawLineTo(this.next);\n\t//   }\n\t// };\n\n\n/***/ },\n/* 11 */\n/*!********************************************!*\\\n  !*** ./src/flowchart.symbol.subroutine.js ***!\n  \\********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Symbol = __webpack_require__(/*! ./flowchart.symbol */ 2);\n\tvar inherits = __webpack_require__(/*! ./flowchart.helpers */ 1).inherits;\n\t\n\tfunction Subroutine(chart, options) {\n\t  var symbol = chart.paper.rect(0, 0, 0, 0);\n\t  options = options || {};\n\t  Symbol.call(this, chart, options, symbol);\n\t\n\t  symbol.attr({\n\t    width: this.text.getBBox().width + 4 * this.getAttr('text-margin')\n\t  });\n\t\n\t  this.text.attr({\n\t    'x': 2 * this.getAttr('text-margin')\n\t  });\n\t\n\t  var innerWrap = chart.paper.rect(0, 0, 0, 0);\n\t  innerWrap.attr({\n\t    x: this.getAttr('text-margin'),\n\t    stroke: this.getAttr('element-color'),\n\t    'stroke-width': this.getAttr('line-width'),\n\t    width: this.text.getBBox().width + 2 * this.getAttr('text-margin'),\n\t    height: this.text.getBBox().height + 2 * this.getAttr('text-margin'),\n\t    fill: this.getAttr('fill')\n\t  });\n\t  if (options.key) { innerWrap.node.id = options.key + 'i'; }\n\t\n\t  var font = this.getAttr('font');\n\t  var fontF = this.getAttr('font-family');\n\t  var fontW = this.getAttr('font-weight');\n\t\n\t  if (font) innerWrap.attr({ 'font': font });\n\t  if (fontF) innerWrap.attr({ 'font-family': fontF });\n\t  if (fontW) innerWrap.attr({ 'font-weight': fontW });\n\t\n\t  if (options.link) { innerWrap.attr('href', options.link); }\n\t  if (options.target) { innerWrap.attr('target', options.target); }\n\t  this.group.push(innerWrap);\n\t  innerWrap.insertBefore(this.text);\n\t\n\t  this.initialize();\n\t}\n\tinherits(Subroutine, Symbol);\n\t\n\tmodule.exports = Subroutine;\n\n\n/***/ },\n/* 12 */\n/*!***********************************!*\\\n  !*** ./src/flowchart.defaults.js ***!\n  \\***********************************/\n/***/ function(module, exports) {\n\n\t// defaults\n\tmodule.exports = {\n\t  'x': 0,\n\t  'y': 0,\n\t  'line-width': 3,\n\t  'line-length': 50,\n\t  'text-margin': 10,\n\t  'font-size': 14,\n\t  'font-color': 'black',\n\t  // 'font': 'normal',\n\t  // 'font-family': 'calibri',\n\t  // 'font-weight': 'normal',\n\t  'line-color': 'black',\n\t  'element-color': 'black',\n\t  'fill': 'white',\n\t  'yes-text': 'yes',\n\t  'no-text': 'no',\n\t  'arrow-end': 'block',\n\t  'class': 'flowchart',\n\t  'scale': 1,\n\t  'symbols': {\n\t    'start': {},\n\t    'end': {},\n\t    'condition': {},\n\t    'inputoutput': {},\n\t    'operation': {},\n\t    'subroutine': {}\n\t  }//,\n\t  // 'flowstate' : {\n\t  //   'past' : { 'fill': '#CCCCCC', 'font-size': 12},\n\t  //   'current' : {'fill': 'yellow', 'font-color': 'red', 'font-weight': 'bold'},\n\t  //   'future' : { 'fill': '#FFFF99'},\n\t  //   'invalid': {'fill': '#444444'}\n\t  // }\n\t};\n\n\n/***/ },\n/* 13 */\n/*!**************************************!*\\\n  !*** ./src/flowchart.parseObject.js ***!\n  \\**************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar FlowChart = __webpack_require__(/*! ./flowchart.chart */ 5);\n\tvar Start = __webpack_require__(/*! ./flowchart.symbol.start */ 10);\n\tvar End = __webpack_require__(/*! ./flowchart.symbol.end */ 7);\n\tvar Operation = __webpack_require__(/*! ./flowchart.symbol.operation */ 9);\n\tvar InputOutput = __webpack_require__(/*! ./flowchart.symbol.inputoutput */ 8);\n\tvar Subroutine = __webpack_require__(/*! ./flowchart.symbol.subroutine */ 11);\n\tvar Condition = __webpack_require__(/*! ./flowchart.symbol.condition */ 4);\n\t\n\t\n\tfunction parseJson(symbolsArray, directionsArray) {\n\t\n\t\n\t    var chart = {\n\t        symbols: symbolsArray,\n\t        start: null,\n\t        drawSVG: function (container, options) {\n\t            var self = this;\n\t\n\t            if (this.diagram) {\n\t                this.diagram.clean();\n\t            }\n\t\n\t            var diagram = new FlowChart(container, options);\n\t            this.diagram = diagram;\n\t            var dispSymbols = {};\n\t\n\t            function getDisplaySymbol(s) {\n\t\n\t                if (dispSymbols[s.key]) {\n\t                    return dispSymbols[s.key];\n\t                }\n\t\n\t                switch (s.symbolType) {\n\t                    case 'start':\n\t                        dispSymbols[s.key] = new Start(diagram, s);\n\t                        break;\n\t                    case 'end':\n\t                        dispSymbols[s.key] = new End(diagram, s);\n\t                        break;\n\t                    case 'operation':\n\t                        dispSymbols[s.key] = new Operation(diagram, s);\n\t                        break;\n\t                    case 'inputoutput':\n\t                        dispSymbols[s.key] = new InputOutput(diagram, s);\n\t                        break;\n\t                    case 'subroutine':\n\t                        dispSymbols[s.key] = new Subroutine(diagram, s);\n\t                        break;\n\t                    case 'condition':\n\t                        dispSymbols[s.key] = new Condition(diagram, s);\n\t                        break;\n\t                    default:\n\t                        return new Error('Wrong symbol type!');\n\t                }\n\t\n\t                return dispSymbols[s.key];\n\t            }\n\t\n\t            (function constructChart(s, prevDisp, prev) {\n\t                var dispSymb = getDisplaySymbol(s);\n\t\n\t                if (self.start === s) {\n\t                    diagram.startWith(dispSymb);\n\t                } else if (prevDisp && prev && !prevDisp.pathOk) {\n\t                    if (prevDisp instanceof (Condition)) {\n\t                        if (prev.yes === s) {\n\t                            prevDisp.yes(dispSymb);\n\t                        }\n\t                        if (prev.no === s) {\n\t                            prevDisp.no(dispSymb);\n\t                        }\n\t                    } else {\n\t                        prevDisp.then(dispSymb);\n\t                    }\n\t                }\n\t\n\t                if (dispSymb.pathOk) {\n\t                    return dispSymb;\n\t                }\n\t\n\t                if (dispSymb instanceof (Condition)) {\n\t                    if (s.yes) {\n\t                        constructChart(s.yes, dispSymb, s);\n\t                    }\n\t                    if (s.no) {\n\t                        constructChart(s.no, dispSymb, s);\n\t                    }\n\t                } else if (s.next) {\n\t                    constructChart(s.next, dispSymb, s);\n\t                }\n\t\n\t                return dispSymb;\n\t            })(this.start);\n\t\n\t            diagram.render();\n\t        },\n\t        clean: function () {\n\t            this.diagram.clean();\n\t        }\n\t    };\n\t\n\t\n\t    for (var key in directionsArray) {\n\t\n\t        var direction = directionsArray[key];\n\t\n\t        var symbol = symbolsArray[direction.key];\n\t        var nextSymbol = symbolsArray[direction.nextKey];\n\t\n\t        symbol[direction.next] = nextSymbol;\n\t        symbol['direction_' + direction.next] = direction.direction;\n\t\n\t        if (!chart.start) {\n\t            chart.start = symbol;\n\t        }\n\t\n\t        // console.log(symbol.symbolType + \" --> \" + nextSymbol.symbolType);\n\t        // console.log('direction_' + direction.next + \" -->  \" + symbol['direction_' + direction.next]);\n\t        // console.log(\"\\n\");\n\t    }\n\t\n\t    return chart;\n\t}\n\t\n\tmodule.exports = parseJson;\n\n\n/***/ },\n/* 14 */\n/*!*******************************!*\\\n  !*** ./src/flowchart.shim.js ***!\n  \\*******************************/\n/***/ function(module, exports) {\n\n\t// add indexOf to non ECMA-262 standard compliant browsers\n\tif (!Array.prototype.indexOf) {\n\t  Array.prototype.indexOf = function (searchElement /*, fromIndex */ ) {\n\t    \"use strict\";\n\t    if (this === null) {\n\t      throw new TypeError();\n\t    }\n\t    var t = Object(this);\n\t    var len = t.length >>> 0;\n\t    if (len === 0) {\n\t      return -1;\n\t    }\n\t    var n = 0;\n\t    if (arguments.length > 0) {\n\t      n = Number(arguments[1]);\n\t      if (n != n) { // shortcut for verifying if it's NaN\n\t        n = 0;\n\t      } else if (n !== 0 && n != Infinity && n != -Infinity) {\n\t        n = (n > 0 || -1) * Math.floor(Math.abs(n));\n\t      }\n\t    }\n\t    if (n >= len) {\n\t      return -1;\n\t    }\n\t    var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);\n\t    for (; k < len; k++) {\n\t      if (k in t && t[k] === searchElement) {\n\t        return k;\n\t      }\n\t    }\n\t    return -1;\n\t  };\n\t}\n\t\n\t// add lastIndexOf to non ECMA-262 standard compliant browsers\n\tif (!Array.prototype.lastIndexOf) {\n\t  Array.prototype.lastIndexOf = function(searchElement /*, fromIndex*/) {\n\t    \"use strict\";\n\t    if (this === null) {\n\t      throw new TypeError();\n\t    }\n\t    var t = Object(this);\n\t    var len = t.length >>> 0;\n\t    if (len === 0) {\n\t      return -1;\n\t    }\n\t    var n = len;\n\t    if (arguments.length > 1) {\n\t      n = Number(arguments[1]);\n\t      if (n != n) {\n\t        n = 0;\n\t      } else if (n !== 0 && n != (1 / 0) && n != -(1 / 0)) {\n\t        n = (n > 0 || -1) * Math.floor(Math.abs(n));\n\t      }\n\t    }\n\t    var k = n >= 0 ? Math.min(n, len - 1) : len - Math.abs(n);\n\t    for (; k >= 0; k--) {\n\t      if (k in t && t[k] === searchElement) {\n\t        return k;\n\t      }\n\t    }\n\t    return -1;\n\t  };\n\t}\n\t\n\tif (!String.prototype.trim) {\n\t  String.prototype.trim = function() {\n\t    return this.replace(/^\\s+|\\s+$/g, '');\n\t  };\n\t}\n\n/***/ },\n/* 15 */\n/*!******************************!*\\\n  !*** ./src/jquery-plugin.js ***!\n  \\******************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tif (typeof jQuery != 'undefined') {\n\t\tvar parse = __webpack_require__(/*! ./flowchart.parse */ 6);\n\t\t(function( $ ) {\n\t\t\t$.fn.flowChart = function( options ) {\n\t\t\t\treturn this.each(function() {\n\t\t\t\t\tvar $this = $(this);\n\t\t\t\t\tvar chart = parse($this.text());\n\t\t\t\t\t$this.html('');\n\t\t\t\t\tchart.drawSVG(this, options);\n\t\t\t\t});\n\t\t\t};\n\t\t})(jQuery); // eslint-disable-line\n\t}\n\n\n/***/ },\n/* 16 */\n/*!**************************!*\\\n  !*** external \"Raphael\" ***!\n  \\**************************/\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_16__;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** flowchart.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 443db6e2f85f66074dae\n **/","require('./src/flowchart.shim');\nvar parse = require('./src/flowchart.parse');\nvar parseObject = require('./src/flowchart.parseObject');\nrequire('./src/jquery-plugin');\n\nvar FlowChart = {\n\tparse: parse,\n\tparseObject: parseObject\n};\n\nif (typeof window !== 'undefined') {\n\twindow.flowchart = FlowChart;\n}\n\nmodule.exports = FlowChart;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./index.js\n ** module id = 0\n ** module chunks = 0\n **/","function _defaults(options, defaultOptions) {\n  if (!options || typeof options === 'function') {\n    return defaultOptions;\n  }\n\n  var merged = {};\n  for (var attrname in defaultOptions) {\n    merged[attrname] = defaultOptions[attrname];\n  }\n\n  for (attrname in options) {\n    if (options[attrname]) {\n      if (typeof merged[attrname] === 'object') {\n        merged[attrname] = _defaults(merged[attrname], options[attrname]);\n      } else {\n        merged[attrname] = options[attrname];\n      }\n    }\n  }\n  return merged;\n}\n\nfunction _inherits(ctor, superCtor) {\n  if (typeof(Object.create) === 'function') {\n    // implementation from standard node.js 'util' module\n    ctor.super_ = superCtor;\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  } else {\n    // old school shim for old browsers\n    ctor.super_ = superCtor;\n    var TempCtor = function () {};\n    TempCtor.prototype = superCtor.prototype;\n    ctor.prototype = new TempCtor();\n    ctor.prototype.constructor = ctor;\n  }\n}\n\n// move dependent functions to a container so that\n// they can be overriden easier in no jquery environment (node.js)\nmodule.exports = {\n  defaults: _defaults,\n  inherits: _inherits\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/flowchart.helpers.js\n ** module id = 1\n ** module chunks = 0\n **/","var drawAPI = require('./flowchart.functions');\nvar drawLine = drawAPI.drawLine;\nvar checkLineIntersection = drawAPI.checkLineIntersection;\n\nfunction Symbol(chart, options, symbol) {\n  this.chart = chart;\n  this.group = this.chart.paper.set();\n  this.symbol = symbol;\n  this.connectedTo = [];\n  this.symbolType = options.symbolType;\n  this.flowstate = (options.flowstate || 'future');\n\n  this.next_direction = options.next && options['direction_next'] ? options['direction_next'] : undefined;\n\n  this.text = this.chart.paper.text(0, 0, options.text);\n  //Raphael does not support the svg group tag so setting the text node id to the symbol node id plus t\n  if (options.key) { this.text.node.id = options.key + 't'; }\n  this.text.node.setAttribute('class', this.getAttr('class') + 't');\n\n  this.text.attr({\n    'text-anchor': 'start',\n    'x'          : this.getAttr('text-margin'),\n    'fill'       : this.getAttr('font-color'),\n    'font-size'  : this.getAttr('font-size')\n  });\n\n  var font  = this.getAttr('font');\n  var fontF = this.getAttr('font-family');\n  var fontW = this.getAttr('font-weight');\n\n  if (font) this.text.attr({ 'font': font });\n  if (fontF) this.text.attr({ 'font-family': fontF });\n  if (fontW) this.text.attr({ 'font-weight': fontW });\n\n  if (options.link) { this.text.attr('href', options.link); }\n  if (options.target) { this.text.attr('target', options.target); }\n\n  var maxWidth = this.getAttr('maxWidth');\n  if (maxWidth) {\n    // using this approach: http://stackoverflow.com/a/3153457/22466\n    var words = options.text.split(' ');\n    var tempText = \"\";\n    for (var i=0, ii=words.length; i<ii; i++) {\n      var word = words[i];\n      this.text.attr(\"text\", tempText + \" \" + word);\n      if (this.text.getBBox().width > maxWidth) {\n        tempText += \"\\n\" + word;\n      } else {\n        tempText += \" \" + word;\n      }\n    }\n    this.text.attr(\"text\", tempText.substring(1));\n  }\n\n  this.group.push(this.text);\n\n  if (symbol) {\n    var tmpMargin = this.getAttr('text-margin');\n\n    symbol.attr({\n      'fill' : this.getAttr('fill'),\n      'stroke' : this.getAttr('element-color'),\n      'stroke-width' : this.getAttr('line-width'),\n      'width' : this.text.getBBox().width + 2 * tmpMargin,\n      'height' : this.text.getBBox().height + 2 * tmpMargin\n    });\n\n    symbol.node.setAttribute('class', this.getAttr('class'));\n\n    if (options.link) { symbol.attr('href', options.link); }\n    if (options.target) { symbol.attr('target', options.target); }\n    if (options.key) { symbol.node.id = options.key; }\n\n    this.group.push(symbol);\n    symbol.insertBefore(this.text);\n\n    this.text.attr({\n      'y': symbol.getBBox().height/2\n    });\n\n    this.initialize();\n  }\n\n}\n\n/* Gets the attribute based on Flowstate, Symbol-Name and default, first found wins */\nSymbol.prototype.getAttr = function(attName) {\n  if (!this.chart) {\n    return undefined;\n  }\n  var opt3 = (this.chart.options) ? this.chart.options[attName] : undefined;\n  var opt2 = (this.chart.options.symbols) ? this.chart.options.symbols[this.symbolType][attName] : undefined;\n  var opt1;\n  if (this.chart.options.flowstate && this.chart.options.flowstate[this.flowstate]) {\n    opt1 = this.chart.options.flowstate[this.flowstate][attName];\n  }\n  return (opt1 || opt2 || opt3);\n};\n\nSymbol.prototype.initialize = function() {\n  this.group.transform('t' + this.getAttr('line-width') + ',' + this.getAttr('line-width'));\n\n  this.width = this.group.getBBox().width;\n  this.height = this.group.getBBox().height;\n};\n\nSymbol.prototype.getCenter = function() {\n  return {x: this.getX() + this.width/2,\n          y: this.getY() + this.height/2};\n};\n\nSymbol.prototype.getX = function() {\n  return this.group.getBBox().x;\n};\n\nSymbol.prototype.getY = function() {\n  return this.group.getBBox().y;\n};\n\nSymbol.prototype.shiftX = function(x) {\n  this.group.transform('t' + (this.getX() + x) + ',' + this.getY());\n};\n\nSymbol.prototype.setX = function(x) {\n  this.group.transform('t' + x + ',' + this.getY());\n};\n\nSymbol.prototype.shiftY = function(y) {\n  this.group.transform('t' + this.getX() + ',' + (this.getY() + y));\n};\n\nSymbol.prototype.setY = function(y) {\n  this.group.transform('t' + this.getX() + ',' + y);\n};\n\nSymbol.prototype.getTop = function() {\n  var y = this.getY();\n  var x = this.getX() + this.width/2;\n  return {x: x, y: y};\n};\n\nSymbol.prototype.getBottom = function() {\n  var y = this.getY() + this.height;\n  var x = this.getX() + this.width/2;\n  return {x: x, y: y};\n};\n\nSymbol.prototype.getLeft = function() {\n  var y = this.getY() + this.group.getBBox().height/2;\n  var x = this.getX();\n  return {x: x, y: y};\n};\n\nSymbol.prototype.getRight = function() {\n  var y = this.getY() + this.group.getBBox().height/2;\n  var x = this.getX() + this.group.getBBox().width;\n  return {x: x, y: y};\n};\n\nSymbol.prototype.render = function() {\n  if (this.next) {\n\n    var lineLength = this.getAttr('line-length');\n\n    if (this.next_direction === 'right') {\n\n      var rightPoint = this.getRight();\n\n      if (!this.next.isPositioned) {\n\n        this.next.setY(rightPoint.y - this.next.height/2);\n        this.next.shiftX(this.group.getBBox().x + this.width + lineLength);\n\n        var self = this;\n        (function shift() {\n          var hasSymbolUnder = false;\n          var symb;\n          for (var i = 0, len = self.chart.symbols.length; i < len; i++) {\n            symb = self.chart.symbols[i];\n\n            var diff = Math.abs(symb.getCenter().x - self.next.getCenter().x);\n            if (symb.getCenter().y > self.next.getCenter().y && diff <= self.next.width/2) {\n              hasSymbolUnder = true;\n              break;\n            }\n          }\n\n          if (hasSymbolUnder) {\n            self.next.setX(symb.getX() + symb.width + lineLength);\n            shift();\n          }\n        })();\n\n        this.next.isPositioned = true;\n\n        this.next.render();\n      }\n    } else {\n      var bottomPoint = this.getBottom();\n\n      if (!this.next.isPositioned) {\n        this.next.shiftY(this.getY() + this.height + lineLength);\n        this.next.setX(bottomPoint.x - this.next.width/2);\n        this.next.isPositioned = true;\n\n        this.next.render();\n      }\n    }\n  }\n};\n\nSymbol.prototype.renderLines = function() {\n  if (this.next) {\n    if (this.next_direction) {\n      this.drawLineTo(this.next, '', this.next_direction);\n    } else {\n      this.drawLineTo(this.next);\n    }\n  }\n};\n\nSymbol.prototype.drawLineTo = function(symbol, text, origin) {\n  if (this.connectedTo.indexOf(symbol) < 0) {\n    this.connectedTo.push(symbol);\n  }\n\n  var x = this.getCenter().x,\n      y = this.getCenter().y,\n      right = this.getRight(),\n      bottom = this.getBottom(),\n      left = this.getLeft();\n\n  var symbolX = symbol.getCenter().x,\n      symbolY = symbol.getCenter().y,\n      symbolTop = symbol.getTop(),\n      symbolRight = symbol.getRight(),\n      symbolLeft = symbol.getLeft();\n\n  var isOnSameColumn = x === symbolX,\n      isOnSameLine = y === symbolY,\n      isUnder = y < symbolY,\n      isUpper = y > symbolY,\n      isLeft = x > symbolX,\n      isRight = x < symbolX;\n\n  var maxX = 0,\n      line,\n      lineLength = this.getAttr('line-length'),\n      lineWith = this.getAttr('line-width');\n\n  if ((!origin || origin === 'bottom') && isOnSameColumn && isUnder) {\n    line = drawLine(this.chart, bottom, symbolTop, text);\n    this.bottomStart = true;\n    symbol.topEnd = true;\n    maxX = bottom.x;\n  } else if ((!origin || origin === 'right') && isOnSameLine && isRight) {\n    line = drawLine(this.chart, right, symbolLeft, text);\n    this.rightStart = true;\n    symbol.leftEnd = true;\n    maxX = symbolLeft.x;\n  } else if ((!origin || origin === 'left') && isOnSameLine && isLeft) {\n    line = drawLine(this.chart, left, symbolRight, text);\n    this.leftStart = true;\n    symbol.rightEnd = true;\n    maxX = symbolRight.x;\n  } else if ((!origin || origin === 'right') && isOnSameColumn && isUpper) {\n    line = drawLine(this.chart, right, [\n      {x: right.x + lineLength/2, y: right.y},\n      {x: right.x + lineLength/2, y: symbolTop.y - lineLength/2},\n      {x: symbolTop.x, y: symbolTop.y - lineLength/2},\n      {x: symbolTop.x, y: symbolTop.y}\n    ], text);\n    this.rightStart = true;\n    symbol.topEnd = true;\n    maxX = right.x + lineLength/2;\n  } else if ((!origin || origin === 'right') && isOnSameColumn && isUnder) {\n    line = drawLine(this.chart, right, [\n      {x: right.x + lineLength/2, y: right.y},\n      {x: right.x + lineLength/2, y: symbolTop.y - lineLength/2},\n      {x: symbolTop.x, y: symbolTop.y - lineLength/2},\n      {x: symbolTop.x, y: symbolTop.y}\n    ], text);\n    this.rightStart = true;\n    symbol.topEnd = true;\n    maxX = right.x + lineLength/2;\n  } else if ((!origin || origin === 'bottom') && isLeft) {\n    if (this.leftEnd && isUpper) {\n      line = drawLine(this.chart, bottom, [\n        {x: bottom.x, y: bottom.y + lineLength/2},\n        {x: bottom.x + (bottom.x - symbolTop.x)/2, y: bottom.y + lineLength/2},\n        {x: bottom.x + (bottom.x - symbolTop.x)/2, y: symbolTop.y - lineLength/2},\n        {x: symbolTop.x, y: symbolTop.y - lineLength/2},\n        {x: symbolTop.x, y: symbolTop.y}\n      ], text);\n    } else {\n      line = drawLine(this.chart, bottom, [\n        {x: bottom.x, y: symbolTop.y - lineLength/2},\n        {x: symbolTop.x, y: symbolTop.y - lineLength/2},\n        {x: symbolTop.x, y: symbolTop.y}\n      ], text);\n    }\n    this.bottomStart = true;\n    symbol.topEnd = true;\n    maxX = bottom.x + (bottom.x - symbolTop.x)/2;\n  } else if ((!origin || origin === 'bottom') && isRight) {\n    line = drawLine(this.chart, bottom, [\n      {x: bottom.x, y: bottom.y + lineLength/2},\n      {x: bottom.x + (bottom.x - symbolTop.x)/2, y: bottom.y + lineLength/2},\n      {x: bottom.x + (bottom.x - symbolTop.x)/2, y: symbolTop.y - lineLength/2},\n      {x: symbolTop.x, y: symbolTop.y - lineLength/2},\n      {x: symbolTop.x, y: symbolTop.y}\n    ], text);\n    this.bottomStart = true;\n    symbol.topEnd = true;\n    maxX = bottom.x + (bottom.x - symbolTop.x)/2;\n  } else if ((origin && origin === 'right') && isLeft) {\n    line = drawLine(this.chart, right, [\n      {x: right.x + lineLength/2, y: right.y},\n      {x: right.x + lineLength/2, y: symbolTop.y - lineLength/2},\n      {x: symbolTop.x, y: symbolTop.y - lineLength/2},\n      {x: symbolTop.x, y: symbolTop.y}\n    ], text);\n    this.rightStart = true;\n    symbol.topEnd = true;\n    maxX = right.x + lineLength/2;\n  } else if ((origin && origin === 'right') && isRight) {\n    line = drawLine(this.chart, right, [\n      {x: symbolTop.x, y: right.y},\n      {x: symbolTop.x, y: symbolTop.y}\n    ], text);\n    this.rightStart = true;\n    symbol.topEnd = true;\n    maxX = right.x + lineLength/2;\n  } else if ((origin && origin === 'bottom') && isOnSameColumn && isUpper) {\n    line = drawLine(this.chart, bottom, [\n      {x: bottom.x, y: bottom.y + lineLength/2},\n      {x: right.x + lineLength/2, y: bottom.y + lineLength/2},\n      {x: right.x + lineLength/2, y: symbolTop.y - lineLength/2},\n      {x: symbolTop.x, y: symbolTop.y - lineLength/2},\n      {x: symbolTop.x, y: symbolTop.y}\n    ], text);\n    this.bottomStart = true;\n    symbol.topEnd = true;\n    maxX = bottom.x + lineLength/2;\n  } else if ((origin === 'left') && isOnSameColumn && isUpper) {\n    var diffX = left.x - lineLength/2;\n    if (symbolLeft.x < left.x) {\n      diffX = symbolLeft.x - lineLength/2;\n    }\n    line = drawLine(this.chart, left, [\n      {x: diffX, y: left.y},\n      {x: diffX, y: symbolTop.y - lineLength/2},\n      {x: symbolTop.x, y: symbolTop.y - lineLength/2},\n      {x: symbolTop.x, y: symbolTop.y}\n    ], text);\n    this.leftStart = true;\n    symbol.topEnd = true;\n    maxX = left.x;\n  } else if ((origin === 'left')) {\n    line = drawLine(this.chart, left, [\n      {x: symbolTop.x + (left.x - symbolTop.x)/ 2, y: left.y},\n      {x: symbolTop.x + (left.x - symbolTop.x)/ 2, y: symbolTop.y - lineLength/2},\n      {x: symbolTop.x, y: symbolTop.y - lineLength/2},\n      {x: symbolTop.x, y: symbolTop.y}\n    ], text);\n    this.leftStart = true;\n    symbol.topEnd = true;\n    maxX = left.x;\n  }\n\n  if (line) {\n    for (var l = 0, llen = this.chart.lines.length; l < llen; l++) {\n      var otherLine = this.chart.lines[l];\n      var len;\n\n      var ePath = otherLine.attr('path'),\n          lPath = line.attr('path');\n\n      for (var iP = 0, lenP = ePath.length - 1; iP < lenP; iP++) {\n        var newPath = [];\n        newPath.push(['M', ePath[iP][1], ePath[iP][2]]);\n        newPath.push(['L', ePath[iP + 1][1], ePath[iP + 1][2]]);\n\n        var line1_from_x = newPath[0][1];\n        var line1_from_y = newPath[0][2];\n        var line1_to_x = newPath[1][1];\n        var line1_to_y = newPath[1][2];\n\n        for (var lP = 0, lenlP = lPath.length - 1; lP < lenlP; lP++) {\n          var newLinePath = [];\n          newLinePath.push(['M', lPath[lP][1], lPath[lP][2]]);\n          newLinePath.push(['L', lPath[lP + 1][1], lPath[lP + 1][2]]);\n\n          var line2_from_x = newLinePath[0][1];\n          var line2_from_y = newLinePath[0][2];\n          var line2_to_x = newLinePath[1][1];\n          var line2_to_y = newLinePath[1][2];\n\n          var res = checkLineIntersection(line1_from_x, line1_from_y, line1_to_x, line1_to_y, line2_from_x, line2_from_y, line2_to_x, line2_to_y);\n          if (res.onLine1 && res.onLine2) {\n\n            var newSegment;\n            if (line2_from_y === line2_to_y) {\n              if (line2_from_x > line2_to_x) {\n                newSegment = ['L', res.x + lineWith * 2,  line2_from_y];\n                lPath.splice(lP + 1, 0, newSegment);\n                newSegment = ['C', res.x + lineWith * 2,  line2_from_y, res.x, line2_from_y - lineWith * 4, res.x - lineWith * 2, line2_from_y];\n                lPath.splice(lP + 2, 0, newSegment);\n                line.attr('path', lPath);\n              } else {\n                newSegment = ['L', res.x - lineWith * 2,  line2_from_y];\n                lPath.splice(lP + 1, 0, newSegment);\n                newSegment = ['C', res.x - lineWith * 2,  line2_from_y, res.x, line2_from_y - lineWith * 4, res.x + lineWith * 2, line2_from_y];\n                lPath.splice(lP + 2, 0, newSegment);\n                line.attr('path', lPath);\n              }\n            } else {\n              if (line2_from_y > line2_to_y) {\n                newSegment = ['L', line2_from_x, res.y + lineWith * 2];\n                lPath.splice(lP + 1, 0, newSegment);\n                newSegment = ['C', line2_from_x, res.y + lineWith * 2, line2_from_x + lineWith * 4, res.y, line2_from_x, res.y - lineWith * 2];\n                lPath.splice(lP + 2, 0, newSegment);\n                line.attr('path', lPath);\n              } else {\n                newSegment = ['L', line2_from_x, res.y - lineWith * 2];\n                lPath.splice(lP + 1, 0, newSegment);\n                newSegment = ['C', line2_from_x, res.y - lineWith * 2, line2_from_x + lineWith * 4, res.y, line2_from_x, res.y + lineWith * 2];\n                lPath.splice(lP + 2, 0, newSegment);\n                line.attr('path', lPath);\n              }\n            }\n\n            lP += 2;\n            len += 2;\n          }\n        }\n      }\n    }\n\n    this.chart.lines.push(line);\n  }\n\n  if (!this.chart.maxXFromLine || (this.chart.maxXFromLine && maxX > this.chart.maxXFromLine)) {\n    this.chart.maxXFromLine = maxX;\n  }\n};\n\nmodule.exports = Symbol;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/flowchart.symbol.js\n ** module id = 2\n ** module chunks = 0\n **/","function drawPath(chart, location, points) {\n  var i, len;\n  var path = 'M{0},{1}';\n  for (i = 2, len = 2 * points.length + 2; i < len; i+=2) {\n    path += ' L{' + i + '},{' + (i + 1) + '}';\n  }\n  var pathValues = [location.x, location.y];\n  for (i = 0, len = points.length; i < len; i++) {\n    pathValues.push(points[i].x);\n    pathValues.push(points[i].y);\n  }\n  var symbol = chart.paper.path(path, pathValues);\n  symbol.attr('stroke', chart.options['element-color']);\n  symbol.attr('stroke-width', chart.options['line-width']);\n\n  var font = chart.options.font;\n  var fontF = chart.options['font-family'];\n  var fontW = chart.options['font-weight'];\n\n  if (font) symbol.attr({ 'font': font });\n  if (fontF) symbol.attr({ 'font-family': fontF });\n  if (fontW) symbol.attr({ 'font-weight': fontW });\n\n  return symbol;\n}\n\nfunction drawLine(chart, from, to, text) {\n  var i, len;\n\n  if (Object.prototype.toString.call(to) !== '[object Array]') {\n    to = [to];\n  }\n\n  var path = 'M{0},{1}';\n  for (i = 2, len = 2 * to.length + 2; i < len; i+=2) {\n    path += ' L{' + i + '},{' + (i + 1) + '}';\n  }\n  var pathValues = [from.x, from.y];\n  for (i = 0, len = to.length; i < len; i++) {\n    pathValues.push(to[i].x);\n    pathValues.push(to[i].y);\n  }\n\n  var line = chart.paper.path(path, pathValues);\n  line.attr({\n    stroke: chart.options['line-color'],\n    'stroke-width': chart.options['line-width'],\n    'arrow-end': chart.options['arrow-end']\n  });\n\n  var font = chart.options.font;\n  var fontF = chart.options['font-family'];\n  var fontW = chart.options['font-weight'];\n\n  if (font) line.attr({ 'font': font });\n  if (fontF) line.attr({ 'font-family': fontF });\n  if (fontW) line.attr({ 'font-weight': fontW });\n\n  if (text) {\n\n    var centerText = false;\n\n    var textPath = chart.paper.text(0, 0, text);\n\n    var isHorizontal = false;\n    var firstTo = to[0];\n\n    if (from.y === firstTo.y) {\n      isHorizontal = true;\n    }\n\n    var x = 0,\n        y = 0;\n\n    if (centerText) {\n      if (from.x > firstTo.x) {\n        x = from.x - (from.x - firstTo.x)/2;\n      } else {\n        x = firstTo.x - (firstTo.x - from.x)/2;\n      }\n\n      if (from.y > firstTo.y) {\n        y = from.y - (from.y - firstTo.y)/2;\n      } else {\n        y = firstTo.y - (firstTo.y - from.y)/2;\n      }\n\n      if (isHorizontal) {\n        x -= textPath.getBBox().width/2;\n        y -= chart.options['text-margin'];\n      } else {\n        x += chart.options['text-margin'];\n        y -= textPath.getBBox().height/2;\n      }\n    } else {\n      x = from.x;\n      y = from.y;\n\n      if (isHorizontal) {\n        x += chart.options['text-margin']/2;\n        y -= chart.options['text-margin'];\n      } else {\n        x += chart.options['text-margin']/2;\n        y += chart.options['text-margin'];\n      }\n    }\n\n    textPath.attr({\n      'text-anchor': 'start',\n      'font-size': chart.options['font-size'],\n      'fill': chart.options['font-color'],\n      x: x,\n      y: y\n    });\n\n    if (font) textPath.attr({ 'font': font });\n    if (fontF) textPath.attr({ 'font-family': fontF });\n    if (fontW) textPath.attr({ 'font-weight': fontW });\n  }\n\n  return line;\n}\n\nfunction checkLineIntersection(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {\n  // if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point\n  var denominator, a, b, numerator1, numerator2, result = {\n    x: null,\n    y: null,\n    onLine1: false,\n    onLine2: false\n  };\n  denominator = ((line2EndY - line2StartY) * (line1EndX - line1StartX)) - ((line2EndX - line2StartX) * (line1EndY - line1StartY));\n  if (denominator === 0) {\n    return result;\n  }\n  a = line1StartY - line2StartY;\n  b = line1StartX - line2StartX;\n  numerator1 = ((line2EndX - line2StartX) * a) - ((line2EndY - line2StartY) * b);\n  numerator2 = ((line1EndX - line1StartX) * a) - ((line1EndY - line1StartY) * b);\n  a = numerator1 / denominator;\n  b = numerator2 / denominator;\n\n  // if we cast these lines infinitely in both directions, they intersect here:\n  result.x = line1StartX + (a * (line1EndX - line1StartX));\n  result.y = line1StartY + (a * (line1EndY - line1StartY));\n  /*\n  // it is worth noting that this should be the same as:\n  x = line2StartX + (b * (line2EndX - line2StartX));\n  y = line2StartX + (b * (line2EndY - line2StartY));\n  */\n  // if line1 is a segment and line2 is infinite, they intersect if:\n  if (a > 0 && a < 1) {\n    result.onLine1 = true;\n  }\n  // if line2 is a segment and line1 is infinite, they intersect if:\n  if (b > 0 && b < 1) {\n    result.onLine2 = true;\n  }\n  // if line1 and line2 are segments, they intersect if both of the above are true\n  return result;\n}\n\nmodule.exports = {\n\tdrawPath: drawPath,\n\tdrawLine: drawLine,\n\tcheckLineIntersection: checkLineIntersection\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/flowchart.functions.js\n ** module id = 3\n ** module chunks = 0\n **/","var Symbol = require('./flowchart.symbol');\nvar inherits = require('./flowchart.helpers').inherits;\nvar drawAPI = require('./flowchart.functions');\nvar drawPath = drawAPI.drawPath;\n\nfunction Condition(chart, options) {\n  options = options || {};\n  Symbol.call(this, chart, options);\n  this.textMargin = this.getAttr('text-margin');\n  this.yes_direction = 'bottom';\n  this.no_direction = 'right';\n  if (options.yes && options.direction_yes && options.no && !options.direction_no) {\n    if (options.direction_yes === 'right') {\n      this.no_direction = 'bottom';\n      this.yes_direction = 'right';\n    } else {\n      this.no_direction = 'right';\n      this.yes_direction = 'bottom';\n    }\n  } else if (options.yes && !options.direction_yes && options.no && options.direction_no) {\n    if (options.direction_no === 'right') {\n      this.yes_direction = 'bottom';\n      this.no_direction = 'right';\n    } else {\n      this.yes_direction = 'right';\n      this.no_direction = 'bottom';\n    }\n  } else {\n    this.yes_direction = 'bottom';\n    this.no_direction = 'right';\n  }\n\n  this.yes_direction = this.yes_direction || 'bottom';\n  this.no_direction = this.no_direction || 'right';\n\n  this.text.attr({\n    x: this.textMargin * 2\n  });\n\n  var width = this.text.getBBox().width + 3 * this.textMargin;\n  width += width/2;\n  var height = this.text.getBBox().height + 2 * this.textMargin;\n  height += height/2;\n  height = Math.max(width * 0.5, height);\n  var startX = width/4;\n  var startY = height/4;\n\n  this.text.attr({\n    x: startX + this.textMargin/2\n  });\n\n  var start = {x: startX, y: startY};\n  var points = [\n    {x: startX - width/4, y: startY + height/4},\n    {x: startX - width/4 + width/2, y: startY + height/4 + height/2},\n    {x: startX - width/4 + width, y: startY + height/4},\n    {x: startX - width/4 + width/2, y: startY + height/4 - height/2},\n    {x: startX - width/4, y: startY + height/4}\n  ];\n\n  var symbol = drawPath(chart, start, points);\n\n  symbol.attr({\n    stroke: this.getAttr('element-color'),\n    'stroke-width': this.getAttr('line-width'),\n    fill: this.getAttr('fill')\n  });\n  if (options.link) { symbol.attr('href', options.link); }\n  if (options.target) { symbol.attr('target', options.target); }\n  if (options.key) { symbol.node.id = options.key; }\n  symbol.node.setAttribute('class', this.getAttr('class'));\n\n  this.text.attr({\n    y: symbol.getBBox().height/2\n  });\n\n  this.group.push(symbol);\n  symbol.insertBefore(this.text);\n\n  this.initialize();\n}\ninherits(Condition, Symbol);\n\nCondition.prototype.render = function() {\n\n  if (this.yes_direction) {\n    this[this.yes_direction + '_symbol'] = this.yes_symbol;\n  }\n\n  if (this.no_direction) {\n    this[this.no_direction + '_symbol'] = this.no_symbol;\n  }\n\n  var lineLength = this.getAttr('line-length');\n\n  if (this.bottom_symbol) {\n    var bottomPoint = this.getBottom();\n\n    if (!this.bottom_symbol.isPositioned) {\n      this.bottom_symbol.shiftY(this.getY() + this.height + lineLength);\n      this.bottom_symbol.setX(bottomPoint.x - this.bottom_symbol.width/2);\n      this.bottom_symbol.isPositioned = true;\n\n      this.bottom_symbol.render();\n    }\n  }\n\n  if (this.right_symbol) {\n    var rightPoint = this.getRight();\n\n    if (!this.right_symbol.isPositioned) {\n\n      this.right_symbol.setY(rightPoint.y - this.right_symbol.height/2);\n      this.right_symbol.shiftX(this.group.getBBox().x + this.width + lineLength);\n\n      var self = this;\n      (function shift() {\n        var hasSymbolUnder = false;\n        var symb;\n        for (var i = 0, len = self.chart.symbols.length; i < len; i++) {\n          symb = self.chart.symbols[i];\n\n          var diff = Math.abs(symb.getCenter().x - self.right_symbol.getCenter().x);\n          if (symb.getCenter().y > self.right_symbol.getCenter().y && diff <= self.right_symbol.width/2) {\n            hasSymbolUnder = true;\n            break;\n          }\n        }\n\n        if (hasSymbolUnder) {\n          self.right_symbol.setX(symb.getX() + symb.width + lineLength);\n          shift();\n        }\n      })();\n\n      this.right_symbol.isPositioned = true;\n\n      this.right_symbol.render();\n    }\n  }\n};\n\nCondition.prototype.renderLines = function() {\n  if (this.yes_symbol) {\n    this.drawLineTo(this.yes_symbol, this.getAttr('yes-text'), this.yes_direction);\n  }\n\n  if (this.no_symbol) {\n    this.drawLineTo(this.no_symbol, this.getAttr('no-text'), this.no_direction);\n  }\n};\n\nmodule.exports = Condition;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/flowchart.symbol.condition.js\n ** module id = 4\n ** module chunks = 0\n **/","var Raphael = require('raphael');\nvar defaults = require('./flowchart.helpers').defaults;\nvar defaultOptions = require('./flowchart.defaults');\nvar Condition = require('./flowchart.symbol.condition');\n\nfunction FlowChart(container, options) {\n  options = options || {};\n\n  this.paper = new Raphael(container);\n\n  this.options = defaults(options, defaultOptions);\n\n  this.symbols = [];\n  this.lines = [];\n  this.start = null;\n}\n\nFlowChart.prototype.handle = function(symbol) {\n  if (this.symbols.indexOf(symbol) <= -1) {\n    this.symbols.push(symbol);\n  }\n\n  var flowChart = this;\n\n  if (symbol instanceof(Condition)) {\n    symbol.yes = function(nextSymbol) {\n      symbol.yes_symbol = nextSymbol;\n      if(symbol.no_symbol) {\n        symbol.pathOk = true;\n      }\n      return flowChart.handle(nextSymbol);\n    };\n    symbol.no = function(nextSymbol) {\n      symbol.no_symbol = nextSymbol;\n      if(symbol.yes_symbol) {\n        symbol.pathOk = true;\n      }\n      return flowChart.handle(nextSymbol);\n    };\n  } else {\n    symbol.then = function(nextSymbol) {\n      symbol.next = nextSymbol;\n      symbol.pathOk = true;\n      return flowChart.handle(nextSymbol);\n    };\n  }\n\n  return symbol;\n};\n\nFlowChart.prototype.startWith = function(symbol) {\n  this.start = symbol;\n  return this.handle(symbol);\n};\n\nFlowChart.prototype.render = function() {\n  var maxWidth = 0,\n      maxHeight = 0,\n      i = 0,\n      len = 0,\n      maxX = 0,\n      maxY = 0,\n      minX = 0,\n      minY = 0,\n      symbol,\n      line;\n\n  for (i = 0, len = this.symbols.length; i < len; i++) {\n    symbol = this.symbols[i];\n    if (symbol.width > maxWidth) {\n      maxWidth = symbol.width;\n    }\n    if (symbol.height > maxHeight) {\n      maxHeight = symbol.height;\n    }\n  }\n\n  for (i = 0, len = this.symbols.length; i < len; i++) {\n    symbol = this.symbols[i];\n    symbol.shiftX(this.options.x + (maxWidth - symbol.width)/2 + this.options['line-width']);\n    symbol.shiftY(this.options.y + (maxHeight - symbol.height)/2 + this.options['line-width']);\n  }\n\n  this.start.render();\n  // for (i = 0, len = this.symbols.length; i < len; i++) {\n  //   symbol = this.symbols[i];\n  //   symbol.render();\n  // }\n\n  for (i = 0, len = this.symbols.length; i < len; i++) {\n    symbol = this.symbols[i];\n    symbol.renderLines();\n  }\n\n  maxX = this.maxXFromLine;\n\n  for (i = 0, len = this.symbols.length; i < len; i++) {\n    symbol = this.symbols[i];\n    var x = symbol.getX() + symbol.width;\n    var y = symbol.getY() + symbol.height;\n    if (x > maxX) {\n      maxX = x;\n    }\n    if (y > maxY) {\n      maxY = y;\n    }\n  }\n\n  for (i = 0, len = this.lines.length; i < len; i++) {\n    line = this.lines[i].getBBox();\n    var x = line.x;\n    var y = line.y;\n    var x2 = line.x2;\n    var y2 = line.y2;\n    if (x < minX) {\n      minX = x;\n    }\n    if (y < minY) {\n      minY = y;\n    }\n    if (x2 > maxX) {\n      maxX = x2;\n    }\n    if (y2 > maxY) {\n      maxY = y2;\n    }\n  }\n\n  var scale = this.options['scale'];\n  var lineWidth = this.options['line-width'];\n\n  if (minX < 0) minX -= lineWidth;\n  if (minY < 0) minY -= lineWidth;\n\n  var width = maxX + lineWidth - minX;\n  var height = maxY + lineWidth - minY;\n\n  this.paper.setSize(width * scale, height * scale);\n  this.paper.setViewBox(minX, minY, width, height, true);\n};\n\nFlowChart.prototype.clean = function() {\n  if (this.paper) {\n    var paperDom = this.paper.canvas;\n    paperDom.parentNode.removeChild(paperDom);\n  }\n};\n\nmodule.exports = FlowChart;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/flowchart.chart.js\n ** module id = 5\n ** module chunks = 0\n **/","var FlowChart = require('./flowchart.chart');\nvar Start = require('./flowchart.symbol.start');\nvar End = require('./flowchart.symbol.end');\nvar Operation = require('./flowchart.symbol.operation');\nvar InputOutput = require('./flowchart.symbol.inputoutput');\nvar Subroutine = require('./flowchart.symbol.subroutine');\nvar Condition = require('./flowchart.symbol.condition');\n\nfunction parse(input) {\n  input = input || '';\n  input = input.trim();\n\n  var chart = {\n    symbols: {},\n    start: null,\n    drawSVG: function(container, options) {\n      var self = this;\n\n      if (this.diagram) {\n        this.diagram.clean();\n      }\n\n      var diagram = new FlowChart(container, options);\n      this.diagram = diagram;\n      var dispSymbols = {};\n\n      function getDisplaySymbol(s) {\n        if (dispSymbols[s.key]) {\n          return dispSymbols[s.key];\n        }\n\n        switch (s.symbolType) {\n          case 'start':\n            dispSymbols[s.key] = new Start(diagram, s);\n            break;\n          case 'end':\n            dispSymbols[s.key] = new End(diagram, s);\n            break;\n          case 'operation':\n            dispSymbols[s.key] = new Operation(diagram, s);\n            break;\n          case 'inputoutput':\n            dispSymbols[s.key] = new InputOutput(diagram, s);\n            break;\n          case 'subroutine':\n            dispSymbols[s.key] = new Subroutine(diagram, s);\n            break;\n          case 'condition':\n            dispSymbols[s.key] = new Condition(diagram, s);\n            break;\n          default:\n            return new Error('Wrong symbol type!');\n        }\n\n        return dispSymbols[s.key];\n      }\n\n      (function constructChart(s, prevDisp, prev) {\n        var dispSymb = getDisplaySymbol(s);\n\n        if (self.start === s) {\n          diagram.startWith(dispSymb);\n        } else if (prevDisp && prev && !prevDisp.pathOk) {\n          if (prevDisp instanceof(Condition)) {\n            if (prev.yes === s) {\n              prevDisp.yes(dispSymb);\n            }\n            if (prev.no === s) {\n              prevDisp.no(dispSymb);\n            }\n          } else {\n            prevDisp.then(dispSymb);\n          }\n        }\n\n        if (dispSymb.pathOk) {\n          return dispSymb;\n        }\n\n        if (dispSymb instanceof(Condition)) {\n          if (s.yes) {\n            constructChart(s.yes, dispSymb, s);\n          }\n          if (s.no) {\n            constructChart(s.no, dispSymb, s);\n          }\n        } else if (s.next) {\n          constructChart(s.next, dispSymb, s);\n        }\n\n        return dispSymb;\n      })(this.start);\n\n      diagram.render();\n    },\n    clean: function() {\n      this.diagram.clean();\n    }\n  };\n\n  var lines = [];\n  var prevBreak = 0;\n  for (var i0 = 1, i0len = input.length; i0 < i0len; i0++) {\n    if(input[i0] === '\\n' && input[i0 - 1] !== '\\\\') {\n      var line0 = input.substring(prevBreak, i0);\n      prevBreak = i0 + 1;\n      lines.push(line0.replace(/\\\\\\n/g, '\\n'));\n    }\n  }\n\n  if(prevBreak < input.length) {\n    lines.push(input.substr(prevBreak));\n  }\n\n  for (var l = 1, len = lines.length; l < len;) {\n    var currentLine = lines[l];\n\n    if (currentLine.indexOf('->') < 0 && currentLine.indexOf('=>') < 0) {\n      lines[l - 1] += '\\n' + currentLine;\n      lines.splice(l, 1);\n      len--;\n    } else {\n      l++;\n    }\n  }\n\n  function getSymbol(s) {\n    var startIndex = s.indexOf('(') + 1;\n    var endIndex = s.indexOf(')');\n    if (startIndex >= 0 && endIndex >= 0) {\n      return chart.symbols[s.substring(0, startIndex - 1)];\n    }\n    return chart.symbols[s];\n  }\n\n  function getNextPath(s) {\n    var next = 'next';\n    var startIndex = s.indexOf('(') + 1;\n    var endIndex = s.indexOf(')');\n    if (startIndex >= 0 && endIndex >= 0) {\n      next = flowSymb.substring(startIndex, endIndex);\n      if (next.indexOf(',') < 0) {\n        if (next !== 'yes' && next !== 'no') {\n          next = 'next, ' + next;\n        }\n      }\n    }\n    return next;\n  }\n\n  while (lines.length > 0) {\n    var line = lines.splice(0, 1)[0];\n\n    if (line.indexOf('=>') >= 0) {\n      // definition\n      var parts = line.split('=>');\n      var symbol = {\n        key: parts[0],\n        symbolType: parts[1],\n        text: null,\n        link: null,\n        target: null,\n        flowstate: null\n      };\n\n      var sub;\n\n      if (symbol.symbolType.indexOf(': ') >= 0) {\n        sub = symbol.symbolType.split(': ');\n        symbol.symbolType = sub.shift();\n        symbol.text = sub.join(': ');\n      }\n\n      if (symbol.text && symbol.text.indexOf(':>') >= 0) {\n        sub = symbol.text.split(':>');\n        symbol.text = sub.shift();\n        symbol.link = sub.join(':>');\n      } else if (symbol.symbolType.indexOf(':>') >= 0) {\n        sub = symbol.symbolType.split(':>');\n        symbol.symbolType = sub.shift();\n        symbol.link = sub.join(':>');\n      }\n\n      if (symbol.symbolType.indexOf('\\n') >= 0) {\n        symbol.symbolType = symbol.symbolType.split('\\n')[0];\n      }\n\n      /* adding support for links */\n      if (symbol.link) {\n        var startIndex = symbol.link.indexOf('[') + 1;\n        var endIndex = symbol.link.indexOf(']');\n        if (startIndex >= 0 && endIndex >= 0) {\n          symbol.target = symbol.link.substring(startIndex, endIndex);\n          symbol.link = symbol.link.substring(0, startIndex - 1);\n        }\n      }\n      /* end of link support */\n\n      /* adding support for flowstates */\n      if (symbol.text) {\n        if (symbol.text.indexOf('|') >= 0) {\n          var txtAndState = symbol.text.split('|');\n          symbol.flowstate = txtAndState.pop().trim();\n          symbol.text = txtAndState.join('|');\n        }\n      }\n      /* end of flowstate support */\n\n      chart.symbols[symbol.key] = symbol;\n\n    } else if (line.indexOf('->') >= 0) {\n      // flow\n      var flowSymbols = line.split('->');\n      for (var i = 0, lenS = flowSymbols.length; i < lenS; i++) {\n        var flowSymb = flowSymbols[i];\n\n        var realSymb = getSymbol(flowSymb);\n        var next = getNextPath(flowSymb);\n\n        var direction = null;\n        if (next.indexOf(',') >= 0) {\n          var condOpt = next.split(',');\n          next = condOpt[0];\n          direction = condOpt[1].trim();\n        }\n\n        if (!chart.start) {\n          chart.start = realSymb;\n        }\n\n        if (i + 1 < lenS) {\n          var nextSymb = flowSymbols[i + 1];\n          realSymb[next] = getSymbol(nextSymb);\n          realSymb['direction_' + next] = direction;\n          direction = null;\n        }\n      }\n    }\n\n  }\n  return chart;\n}\n\nmodule.exports = parse;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/flowchart.parse.js\n ** module id = 6\n ** module chunks = 0\n **/","var Symbol = require('./flowchart.symbol');\nvar inherits = require('./flowchart.helpers').inherits;\n\nfunction End(chart, options) {\n  var symbol = chart.paper.rect(0, 0, 0, 0, 20);\n  options = options || {};\n  options.text = options.text || 'End';\n  Symbol.call(this, chart, options, symbol);\n}\ninherits(End, Symbol);\n\nmodule.exports = End;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/flowchart.symbol.end.js\n ** module id = 7\n ** module chunks = 0\n **/","var Symbol = require('./flowchart.symbol');\nvar inherits = require('./flowchart.helpers').inherits;\nvar drawAPI = require('./flowchart.functions');\nvar drawPath = drawAPI.drawPath;\n\nfunction InputOutput(chart, options) {\n  options = options || {};\n  Symbol.call(this, chart, options);\n  this.textMargin = this.getAttr('text-margin');\n\n  this.text.attr({\n    x: this.textMargin * 3\n  });\n\n  var width = this.text.getBBox().width + 4 * this.textMargin;\n  var height = this.text.getBBox().height + 2 * this.textMargin;\n  var startX = this.textMargin;\n  var startY = height/2;\n\n  var start = {x: startX, y: startY};\n  var points = [\n    {x: startX - this.textMargin, y: height},\n    {x: startX - this.textMargin + width, y: height},\n    {x: startX - this.textMargin + width + 2 * this.textMargin, y: 0},\n    {x: startX - this.textMargin + 2 * this.textMargin, y: 0},\n    {x: startX, y: startY}\n  ];\n\n  var symbol = drawPath(chart, start, points);\n\n  symbol.attr({\n    stroke: this.getAttr('element-color'),\n    'stroke-width': this.getAttr('line-width'),\n    fill: this.getAttr('fill')\n  });\n  if (options.link) { symbol.attr('href', options.link); }\n  if (options.target) { symbol.attr('target', options.target); }\n  if (options.key) { symbol.node.id = options.key; }\n  symbol.node.setAttribute('class', this.getAttr('class'));\n\n  this.text.attr({\n    y: symbol.getBBox().height/2\n  });\n\n  this.group.push(symbol);\n  symbol.insertBefore(this.text);\n\n  this.initialize();\n}\ninherits(InputOutput, Symbol);\n\nInputOutput.prototype.getLeft = function() {\n  var y = this.getY() + this.group.getBBox().height/2;\n  var x = this.getX() + this.textMargin;\n  return {x: x, y: y};\n};\n\nInputOutput.prototype.getRight = function() {\n  var y = this.getY() + this.group.getBBox().height/2;\n  var x = this.getX() + this.group.getBBox().width - this.textMargin;\n  return {x: x, y: y};\n};\n\nmodule.exports = InputOutput;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/flowchart.symbol.inputoutput.js\n ** module id = 8\n ** module chunks = 0\n **/","var Symbol = require('./flowchart.symbol');\nvar inherits = require('./flowchart.helpers').inherits;\n\nfunction Operation(chart, options) {\n  var symbol = chart.paper.rect(0, 0, 0, 0);\n  options = options || {};\n  Symbol.call(this, chart, options, symbol);\n}\ninherits(Operation, Symbol);\n\nmodule.exports = Operation;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/flowchart.symbol.operation.js\n ** module id = 9\n ** module chunks = 0\n **/","var Symbol = require('./flowchart.symbol');\nvar inherits = require('./flowchart.helpers').inherits;\n\nfunction Start(chart, options) {\n  var symbol = chart.paper.rect(0, 0, 0, 0, 20);\n  options = options || {};\n  options.text = options.text || 'Start';\n  Symbol.call(this, chart, options, symbol);\n}\ninherits(Start, Symbol);\n\nmodule.exports = Start;\n\n// Start.prototype.render = function() {\n//   if (this.next) {\n//     var lineLength = this.chart.options.symbols[this.symbolType]['line-length'] || this.chart.options['line-length'];\n\n//     var bottomPoint = this.getBottom();\n//     var topPoint = this.next.getTop();\n\n//     if (!this.next.isPositioned) {\n//       this.next.shiftY(this.getY() + this.height + lineLength);\n//       this.next.setX(bottomPoint.x - this.next.width/2);\n//       this.next.isPositioned = true;\n\n//       this.next.render();\n//     }\n//   }\n// };\n\n// Start.prototype.renderLines = function() {\n//   if (this.next) {\n//     this.drawLineTo(this.next);\n//   }\n// };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/flowchart.symbol.start.js\n ** module id = 10\n ** module chunks = 0\n **/","var Symbol = require('./flowchart.symbol');\nvar inherits = require('./flowchart.helpers').inherits;\n\nfunction Subroutine(chart, options) {\n  var symbol = chart.paper.rect(0, 0, 0, 0);\n  options = options || {};\n  Symbol.call(this, chart, options, symbol);\n\n  symbol.attr({\n    width: this.text.getBBox().width + 4 * this.getAttr('text-margin')\n  });\n\n  this.text.attr({\n    'x': 2 * this.getAttr('text-margin')\n  });\n\n  var innerWrap = chart.paper.rect(0, 0, 0, 0);\n  innerWrap.attr({\n    x: this.getAttr('text-margin'),\n    stroke: this.getAttr('element-color'),\n    'stroke-width': this.getAttr('line-width'),\n    width: this.text.getBBox().width + 2 * this.getAttr('text-margin'),\n    height: this.text.getBBox().height + 2 * this.getAttr('text-margin'),\n    fill: this.getAttr('fill')\n  });\n  if (options.key) { innerWrap.node.id = options.key + 'i'; }\n\n  var font = this.getAttr('font');\n  var fontF = this.getAttr('font-family');\n  var fontW = this.getAttr('font-weight');\n\n  if (font) innerWrap.attr({ 'font': font });\n  if (fontF) innerWrap.attr({ 'font-family': fontF });\n  if (fontW) innerWrap.attr({ 'font-weight': fontW });\n\n  if (options.link) { innerWrap.attr('href', options.link); }\n  if (options.target) { innerWrap.attr('target', options.target); }\n  this.group.push(innerWrap);\n  innerWrap.insertBefore(this.text);\n\n  this.initialize();\n}\ninherits(Subroutine, Symbol);\n\nmodule.exports = Subroutine;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/flowchart.symbol.subroutine.js\n ** module id = 11\n ** module chunks = 0\n **/","// defaults\nmodule.exports = {\n  'x': 0,\n  'y': 0,\n  'line-width': 3,\n  'line-length': 50,\n  'text-margin': 10,\n  'font-size': 14,\n  'font-color': 'black',\n  // 'font': 'normal',\n  // 'font-family': 'calibri',\n  // 'font-weight': 'normal',\n  'line-color': 'black',\n  'element-color': 'black',\n  'fill': 'white',\n  'yes-text': 'yes',\n  'no-text': 'no',\n  'arrow-end': 'block',\n  'class': 'flowchart',\n  'scale': 1,\n  'symbols': {\n    'start': {},\n    'end': {},\n    'condition': {},\n    'inputoutput': {},\n    'operation': {},\n    'subroutine': {}\n  }//,\n  // 'flowstate' : {\n  //   'past' : { 'fill': '#CCCCCC', 'font-size': 12},\n  //   'current' : {'fill': 'yellow', 'font-color': 'red', 'font-weight': 'bold'},\n  //   'future' : { 'fill': '#FFFF99'},\n  //   'invalid': {'fill': '#444444'}\n  // }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/flowchart.defaults.js\n ** module id = 12\n ** module chunks = 0\n **/","var FlowChart = require('./flowchart.chart');\nvar Start = require('./flowchart.symbol.start');\nvar End = require('./flowchart.symbol.end');\nvar Operation = require('./flowchart.symbol.operation');\nvar InputOutput = require('./flowchart.symbol.inputoutput');\nvar Subroutine = require('./flowchart.symbol.subroutine');\nvar Condition = require('./flowchart.symbol.condition');\n\n\nfunction parseJson(symbolsArray, directionsArray) {\n\n\n    var chart = {\n        symbols: symbolsArray,\n        start: null,\n        drawSVG: function (container, options) {\n            var self = this;\n\n            if (this.diagram) {\n                this.diagram.clean();\n            }\n\n            var diagram = new FlowChart(container, options);\n            this.diagram = diagram;\n            var dispSymbols = {};\n\n            function getDisplaySymbol(s) {\n\n                if (dispSymbols[s.key]) {\n                    return dispSymbols[s.key];\n                }\n\n                switch (s.symbolType) {\n                    case 'start':\n                        dispSymbols[s.key] = new Start(diagram, s);\n                        break;\n                    case 'end':\n                        dispSymbols[s.key] = new End(diagram, s);\n                        break;\n                    case 'operation':\n                        dispSymbols[s.key] = new Operation(diagram, s);\n                        break;\n                    case 'inputoutput':\n                        dispSymbols[s.key] = new InputOutput(diagram, s);\n                        break;\n                    case 'subroutine':\n                        dispSymbols[s.key] = new Subroutine(diagram, s);\n                        break;\n                    case 'condition':\n                        dispSymbols[s.key] = new Condition(diagram, s);\n                        break;\n                    default:\n                        return new Error('Wrong symbol type!');\n                }\n\n                return dispSymbols[s.key];\n            }\n\n            (function constructChart(s, prevDisp, prev) {\n                var dispSymb = getDisplaySymbol(s);\n\n                if (self.start === s) {\n                    diagram.startWith(dispSymb);\n                } else if (prevDisp && prev && !prevDisp.pathOk) {\n                    if (prevDisp instanceof (Condition)) {\n                        if (prev.yes === s) {\n                            prevDisp.yes(dispSymb);\n                        }\n                        if (prev.no === s) {\n                            prevDisp.no(dispSymb);\n                        }\n                    } else {\n                        prevDisp.then(dispSymb);\n                    }\n                }\n\n                if (dispSymb.pathOk) {\n                    return dispSymb;\n                }\n\n                if (dispSymb instanceof (Condition)) {\n                    if (s.yes) {\n                        constructChart(s.yes, dispSymb, s);\n                    }\n                    if (s.no) {\n                        constructChart(s.no, dispSymb, s);\n                    }\n                } else if (s.next) {\n                    constructChart(s.next, dispSymb, s);\n                }\n\n                return dispSymb;\n            })(this.start);\n\n            diagram.render();\n        },\n        clean: function () {\n            this.diagram.clean();\n        }\n    };\n\n\n    for (var key in directionsArray) {\n\n        var direction = directionsArray[key];\n\n        var symbol = symbolsArray[direction.key];\n        var nextSymbol = symbolsArray[direction.nextKey];\n\n        symbol[direction.next] = nextSymbol;\n        symbol['direction_' + direction.next] = direction.direction;\n\n        if (!chart.start) {\n            chart.start = symbol;\n        }\n\n        // console.log(symbol.symbolType + \" --> \" + nextSymbol.symbolType);\n        // console.log('direction_' + direction.next + \" -->  \" + symbol['direction_' + direction.next]);\n        // console.log(\"\\n\");\n    }\n\n    return chart;\n}\n\nmodule.exports = parseJson;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/flowchart.parseObject.js\n ** module id = 13\n ** module chunks = 0\n **/","// add indexOf to non ECMA-262 standard compliant browsers\nif (!Array.prototype.indexOf) {\n  Array.prototype.indexOf = function (searchElement /*, fromIndex */ ) {\n    \"use strict\";\n    if (this === null) {\n      throw new TypeError();\n    }\n    var t = Object(this);\n    var len = t.length >>> 0;\n    if (len === 0) {\n      return -1;\n    }\n    var n = 0;\n    if (arguments.length > 0) {\n      n = Number(arguments[1]);\n      if (n != n) { // shortcut for verifying if it's NaN\n        n = 0;\n      } else if (n !== 0 && n != Infinity && n != -Infinity) {\n        n = (n > 0 || -1) * Math.floor(Math.abs(n));\n      }\n    }\n    if (n >= len) {\n      return -1;\n    }\n    var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);\n    for (; k < len; k++) {\n      if (k in t && t[k] === searchElement) {\n        return k;\n      }\n    }\n    return -1;\n  };\n}\n\n// add lastIndexOf to non ECMA-262 standard compliant browsers\nif (!Array.prototype.lastIndexOf) {\n  Array.prototype.lastIndexOf = function(searchElement /*, fromIndex*/) {\n    \"use strict\";\n    if (this === null) {\n      throw new TypeError();\n    }\n    var t = Object(this);\n    var len = t.length >>> 0;\n    if (len === 0) {\n      return -1;\n    }\n    var n = len;\n    if (arguments.length > 1) {\n      n = Number(arguments[1]);\n      if (n != n) {\n        n = 0;\n      } else if (n !== 0 && n != (1 / 0) && n != -(1 / 0)) {\n        n = (n > 0 || -1) * Math.floor(Math.abs(n));\n      }\n    }\n    var k = n >= 0 ? Math.min(n, len - 1) : len - Math.abs(n);\n    for (; k >= 0; k--) {\n      if (k in t && t[k] === searchElement) {\n        return k;\n      }\n    }\n    return -1;\n  };\n}\n\nif (!String.prototype.trim) {\n  String.prototype.trim = function() {\n    return this.replace(/^\\s+|\\s+$/g, '');\n  };\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/flowchart.shim.js\n ** module id = 14\n ** module chunks = 0\n **/","if (typeof jQuery != 'undefined') {\n\tvar parse = require('./flowchart.parse');\n\t(function( $ ) {\n\t\t$.fn.flowChart = function( options ) {\n\t\t\treturn this.each(function() {\n\t\t\t\tvar $this = $(this);\n\t\t\t\tvar chart = parse($this.text());\n\t\t\t\t$this.html('');\n\t\t\t\tchart.drawSVG(this, options);\n\t\t\t});\n\t\t};\n\t})(jQuery); // eslint-disable-line\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/jquery-plugin.js\n ** module id = 15\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_16__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"Raphael\"\n ** module id = 16\n ** module chunks = 0\n **/"],"sourceRoot":""}